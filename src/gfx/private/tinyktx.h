// MIT license see full LICENSE text at end of file
#pragma once
#ifndef TINY_KTX_TINYKTX_H
#define TINY_KTX_TINYKTX_H

//#define TINY_KTX_EXPERIMENTAL_KTX2_SUPPORT

#ifndef TINYKTX_HAVE_UINTXX_T
#include <stdint.h> 	// for uint32_t and int64_t
#endif
#ifndef TINYKTX_HAVE_BOOL
#include <stdbool.h>	// for bool
#endif
#ifndef TINYKTX_HAVE_SIZE_T
#include <stddef.h>		// for size_t
#endif
#ifndef TINYKTX_HAVE_MEMCPY
#include <string.h> 	// for memcpy
#endif

#ifdef __cplusplus
extern "C" {
#endif

#define TINYKTX_MAX_MIPMAPLEVELS 16

typedef struct TinyKtx_Context *TinyKtx_ContextHandle;

typedef void *(*TinyKtx_AllocFunc)(void *user, size_t size);
typedef void (*TinyKtx_FreeFunc)(void *user, void *memory);
typedef size_t (*TinyKtx_ReadFunc)(void *user, void *buffer, size_t byteCount);
typedef bool (*TinyKtx_SeekFunc)(void *user, int64_t offset);
typedef int64_t (*TinyKtx_TellFunc)(void *user);
typedef void (*TinyKtx_ErrorFunc)(void *user, char const *msg);
#ifdef TINY_KTX_EXPERIMENTAL_KTX2_SUPPORT
typedef bool (*TinyKtx_SuperDecompress)(void* user, void* const sgdData, void const* src, size_t srcSize, void const* dst, size_t dstSize);
typedef struct TinyKtx_SuperDecompressTableEntry {
	uint32_t superId;
	TinyKtx_SuperDecompress decompressor;
} TinyKtx_SuperDecompressTableEntry;
#endif

typedef struct TinyKtx_Callbacks {
	TinyKtx_ErrorFunc error;
	TinyKtx_AllocFunc alloc;
	TinyKtx_FreeFunc free;
	TinyKtx_ReadFunc read;
	TinyKtx_SeekFunc seek;
	TinyKtx_TellFunc tell;

#ifdef TINY_KTX_EXPERIMENTAL_KTX2_SUPPORT
	size_t numSuperDecompressors;
	TinyKtx_SuperDecompressTableEntry const* superDecompressors;
#endif
} TinyKtx_Callbacks;

TinyKtx_ContextHandle TinyKtx_CreateContext(TinyKtx_Callbacks const *callbacks, void *user);
void TinyKtx_DestroyContext(TinyKtx_ContextHandle handle);

// reset lets you reuse the context for another file (saves an alloc/free cycle)
void TinyKtx_Reset(TinyKtx_ContextHandle handle);

// call this to read the header file should already be at the start of the KTX data
bool TinyKtx_ReadHeader(TinyKtx_ContextHandle handle);

// this is slow linear search. TODO add iterator style reading of key value pairs
bool TinyKtx_GetValue(TinyKtx_ContextHandle handle, char const *key, void const **value);

bool TinyKtx_Is1D(TinyKtx_ContextHandle handle);
bool TinyKtx_Is2D(TinyKtx_ContextHandle handle);
bool TinyKtx_Is3D(TinyKtx_ContextHandle handle);
bool TinyKtx_IsCubemap(TinyKtx_ContextHandle handle);
bool TinyKtx_IsArray(TinyKtx_ContextHandle handle);

bool TinyKtx_Dimensions(TinyKtx_ContextHandle handle, uint32_t* width, uint32_t* height, uint32_t* depth, uint32_t* slices);
uint32_t TinyKtx_Width(TinyKtx_ContextHandle handle);
uint32_t TinyKtx_Height(TinyKtx_ContextHandle handle);
uint32_t TinyKtx_Depth(TinyKtx_ContextHandle handle);
uint32_t TinyKtx_ArraySlices(TinyKtx_ContextHandle handle);

bool TinyKtx_GetFormatGL(TinyKtx_ContextHandle handle, uint32_t *glformat, uint32_t *gltype, uint32_t *glinternalformat, uint32_t* typesize, uint32_t* glbaseinternalformat);

bool TinyKtx_NeedsGenerationOfMipmaps(TinyKtx_ContextHandle handle);
bool TinyKtx_NeedsEndianCorrecting(TinyKtx_ContextHandle handle);

uint32_t TinyKtx_NumberOfMipmaps(TinyKtx_ContextHandle handle);
uint32_t TinyKtx_ImageSize(TinyKtx_ContextHandle handle, uint32_t mipmaplevel);

bool TinyKtx_IsMipMapLevelUnpacked(TinyKtx_ContextHandle handle, uint32_t mipmaplevel);
// this is required to read Unpacked data correctly
uint32_t TinyKtx_UnpackedRowStride(TinyKtx_ContextHandle handle, uint32_t mipmaplevel);

// data return by ImageRawData is owned by the context. Don't free it!
void const *TinyKtx_ImageRawData(TinyKtx_ContextHandle handle, uint32_t mipmaplevel);

typedef void (*TinyKtx_WriteFunc)(void *user, void const *buffer, size_t byteCount);

typedef struct TinyKtx_WriteCallbacks {
	TinyKtx_ErrorFunc error;
	TinyKtx_AllocFunc alloc;
	TinyKtx_FreeFunc free;
	TinyKtx_WriteFunc write;
} TinyKtx_WriteCallbacks;


bool TinyKtx_WriteImageGL(TinyKtx_WriteCallbacks const *callbacks,
													void *user,
													uint32_t width,
													uint32_t height,
													uint32_t depth,
													uint32_t slices,
													uint32_t mipmaplevels,
													uint32_t format,
													uint32_t internalFormat,
													uint32_t baseFormat,
													uint32_t type,
													uint32_t typeSize,
													bool cubemap,
													uint32_t const *mipmapsizes,
													void const **mipmaps);

// ktx v1 is based on GL (slightly confusing imho) texture format system
// there is format, internal format, type etc.

// we try and expose a more dx12/vulkan/metal style of format
// but obviously still need to GL data so bare with me.
// a TinyKTX_Format is the equivilent to GL/KTX Format and Type
// the API doesn't expose the actual values (which come from GL itself)
// but provide an API call to crack them back into the actual GL values).

// Ktx v2 is based on VkFormat and also DFD, so we now base the
// enumeration values of TinyKtx_Format on the Vkformat values where possible

typedef enum TinyKTX_VkFormat {
	TKTX_VK_FORMAT_UNDEFINED = 0,
	TKTX_VK_FORMAT_R4G4_UNORM_PACK8 = 1,
	TKTX_VK_FORMAT_R4G4B4A4_UNORM_PACK16 = 2,
	TKTX_VK_FORMAT_B4G4R4A4_UNORM_PACK16 = 3,
	TKTX_VK_FORMAT_R5G6B5_UNORM_PACK16 = 4,
	TKTX_VK_FORMAT_B5G6R5_UNORM_PACK16 = 5,
	TKTX_VK_FORMAT_R5G5B5A1_UNORM_PACK16 = 6,
	TKTX_VK_FORMAT_B5G5R5A1_UNORM_PACK16 = 7,
	TKTX_VK_FORMAT_A1R5G5B5_UNORM_PACK16 = 8,
	TKTX_VK_FORMAT_R8_UNORM = 9,
	TKTX_VK_FORMAT_R8_SNORM = 10,
	TKTX_VK_FORMAT_R8_USCALED = 11,
	TKTX_VK_FORMAT_R8_SSCALED = 12,
	TKTX_VK_FORMAT_R8_UINT = 13,
	TKTX_VK_FORMAT_R8_SINT = 14,
	TKTX_VK_FORMAT_R8_SRGB = 15,
	TKTX_VK_FORMAT_R8G8_UNORM = 16,
	TKTX_VK_FORMAT_R8G8_SNORM = 17,
	TKTX_VK_FORMAT_R8G8_USCALED = 18,
	TKTX_VK_FORMAT_R8G8_SSCALED = 19,
	TKTX_VK_FORMAT_R8G8_UINT = 20,
	TKTX_VK_FORMAT_R8G8_SINT = 21,
	TKTX_VK_FORMAT_R8G8_SRGB = 22,
	TKTX_VK_FORMAT_R8G8B8_UNORM = 23,
	TKTX_VK_FORMAT_R8G8B8_SNORM = 24,
	TKTX_VK_FORMAT_R8G8B8_USCALED = 25,
	TKTX_VK_FORMAT_R8G8B8_SSCALED = 26,
	TKTX_VK_FORMAT_R8G8B8_UINT = 27,
	TKTX_VK_FORMAT_R8G8B8_SINT = 28,
	TKTX_VK_FORMAT_R8G8B8_SRGB = 29,
	TKTX_VK_FORMAT_B8G8R8_UNORM = 30,
	TKTX_VK_FORMAT_B8G8R8_SNORM = 31,
	TKTX_VK_FORMAT_B8G8R8_USCALED = 32,
	TKTX_VK_FORMAT_B8G8R8_SSCALED = 33,
	TKTX_VK_FORMAT_B8G8R8_UINT = 34,
	TKTX_VK_FORMAT_B8G8R8_SINT = 35,
	TKTX_VK_FORMAT_B8G8R8_SRGB = 36,
	TKTX_VK_FORMAT_R8G8B8A8_UNORM = 37,
	TKTX_VK_FORMAT_R8G8B8A8_SNORM = 38,
	TKTX_VK_FORMAT_R8G8B8A8_USCALED = 39,
	TKTX_VK_FORMAT_R8G8B8A8_SSCALED = 40,
	TKTX_VK_FORMAT_R8G8B8A8_UINT = 41,
	TKTX_VK_FORMAT_R8G8B8A8_SINT = 42,
	TKTX_VK_FORMAT_R8G8B8A8_SRGB = 43,
	TKTX_VK_FORMAT_B8G8R8A8_UNORM = 44,
	TKTX_VK_FORMAT_B8G8R8A8_SNORM = 45,
	TKTX_VK_FORMAT_B8G8R8A8_USCALED = 46,
	TKTX_VK_FORMAT_B8G8R8A8_SSCALED = 47,
	TKTX_VK_FORMAT_B8G8R8A8_UINT = 48,
	TKTX_VK_FORMAT_B8G8R8A8_SINT = 49,
	TKTX_VK_FORMAT_B8G8R8A8_SRGB = 50,
	TKTX_VK_FORMAT_A8B8G8R8_UNORM_PACK32 = 51,
	TKTX_VK_FORMAT_A8B8G8R8_SNORM_PACK32 = 52,
	TKTX_VK_FORMAT_A8B8G8R8_USCALED_PACK32 = 53,
	TKTX_VK_FORMAT_A8B8G8R8_SSCALED_PACK32 = 54,
	TKTX_VK_FORMAT_A8B8G8R8_UINT_PACK32 = 55,
	TKTX_VK_FORMAT_A8B8G8R8_SINT_PACK32 = 56,
	TKTX_VK_FORMAT_A8B8G8R8_SRGB_PACK32 = 57,
	TKTX_VK_FORMAT_A2R10G10B10_UNORM_PACK32 = 58,
	TKTX_VK_FORMAT_A2R10G10B10_SNORM_PACK32 = 59,
	TKTX_VK_FORMAT_A2R10G10B10_USCALED_PACK32 = 60,
	TKTX_VK_FORMAT_A2R10G10B10_SSCALED_PACK32 = 61,
	TKTX_VK_FORMAT_A2R10G10B10_UINT_PACK32 = 62,
	TKTX_VK_FORMAT_A2R10G10B10_SINT_PACK32 = 63,
	TKTX_VK_FORMAT_A2B10G10R10_UNORM_PACK32 = 64,
	TKTX_VK_FORMAT_A2B10G10R10_SNORM_PACK32 = 65,
	TKTX_VK_FORMAT_A2B10G10R10_USCALED_PACK32 = 66,
	TKTX_VK_FORMAT_A2B10G10R10_SSCALED_PACK32 = 67,
	TKTX_VK_FORMAT_A2B10G10R10_UINT_PACK32 = 68,
	TKTX_VK_FORMAT_A2B10G10R10_SINT_PACK32 = 69,
	TKTX_VK_FORMAT_R16_UNORM = 70,
	TKTX_VK_FORMAT_R16_SNORM = 71,
	TKTX_VK_FORMAT_R16_USCALED = 72,
	TKTX_VK_FORMAT_R16_SSCALED = 73,
	TKTX_VK_FORMAT_R16_UINT = 74,
	TKTX_VK_FORMAT_R16_SINT = 75,
	TKTX_VK_FORMAT_R16_SFLOAT = 76,
	TKTX_VK_FORMAT_R16G16_UNORM = 77,
	TKTX_VK_FORMAT_R16G16_SNORM = 78,
	TKTX_VK_FORMAT_R16G16_USCALED = 79,
	TKTX_VK_FORMAT_R16G16_SSCALED = 80,
	TKTX_VK_FORMAT_R16G16_UINT = 81,
	TKTX_VK_FORMAT_R16G16_SINT = 82,
	TKTX_VK_FORMAT_R16G16_SFLOAT = 83,
	TKTX_VK_FORMAT_R16G16B16_UNORM = 84,
	TKTX_VK_FORMAT_R16G16B16_SNORM = 85,
	TKTX_VK_FORMAT_R16G16B16_USCALED = 86,
	TKTX_VK_FORMAT_R16G16B16_SSCALED = 87,
	TKTX_VK_FORMAT_R16G16B16_UINT = 88,
	TKTX_VK_FORMAT_R16G16B16_SINT = 89,
	TKTX_VK_FORMAT_R16G16B16_SFLOAT = 90,
	TKTX_VK_FORMAT_R16G16B16A16_UNORM = 91,
	TKTX_VK_FORMAT_R16G16B16A16_SNORM = 92,
	TKTX_VK_FORMAT_R16G16B16A16_USCALED = 93,
	TKTX_VK_FORMAT_R16G16B16A16_SSCALED = 94,
	TKTX_VK_FORMAT_R16G16B16A16_UINT = 95,
	TKTX_VK_FORMAT_R16G16B16A16_SINT = 96,
	TKTX_VK_FORMAT_R16G16B16A16_SFLOAT = 97,
	TKTX_VK_FORMAT_R32_UINT = 98,
	TKTX_VK_FORMAT_R32_SINT = 99,
	TKTX_VK_FORMAT_R32_SFLOAT = 100,
	TKTX_VK_FORMAT_R32G32_UINT = 101,
	TKTX_VK_FORMAT_R32G32_SINT = 102,
	TKTX_VK_FORMAT_R32G32_SFLOAT = 103,
	TKTX_VK_FORMAT_R32G32B32_UINT = 104,
	TKTX_VK_FORMAT_R32G32B32_SINT = 105,
	TKTX_VK_FORMAT_R32G32B32_SFLOAT = 106,
	TKTX_VK_FORMAT_R32G32B32A32_UINT = 107,
	TKTX_VK_FORMAT_R32G32B32A32_SINT = 108,
	TKTX_VK_FORMAT_R32G32B32A32_SFLOAT = 109,
	TKTX_VK_FORMAT_R64_UINT = 110,
	TKTX_VK_FORMAT_R64_SINT = 111,
	TKTX_VK_FORMAT_R64_SFLOAT = 112,
	TKTX_VK_FORMAT_R64G64_UINT = 113,
	TKTX_VK_FORMAT_R64G64_SINT = 114,
	TKTX_VK_FORMAT_R64G64_SFLOAT = 115,
	TKTX_VK_FORMAT_R64G64B64_UINT = 116,
	TKTX_VK_FORMAT_R64G64B64_SINT = 117,
	TKTX_VK_FORMAT_R64G64B64_SFLOAT = 118,
	TKTX_VK_FORMAT_R64G64B64A64_UINT = 119,
	TKTX_VK_FORMAT_R64G64B64A64_SINT = 120,
	TKTX_VK_FORMAT_R64G64B64A64_SFLOAT = 121,
	TKTX_VK_FORMAT_B10G11R11_UFLOAT_PACK32 = 122,
	TKTX_VK_FORMAT_E5B9G9R9_UFLOAT_PACK32 = 123,
	TKTX_VK_FORMAT_D16_UNORM = 124,
	TKTX_VK_FORMAT_X8_D24_UNORM_PACK32 = 125,
	TKTX_VK_FORMAT_D32_SFLOAT = 126,
	TKTX_VK_FORMAT_S8_UINT = 127,
	TKTX_VK_FORMAT_D16_UNORM_S8_UINT = 128,
	TKTX_VK_FORMAT_D24_UNORM_S8_UINT = 129,
	TKTX_VK_FORMAT_D32_SFLOAT_S8_UINT = 130,
	TKTX_VK_FORMAT_BC1_RGB_UNORM_BLOCK = 131,
	TKTX_VK_FORMAT_BC1_RGB_SRGB_BLOCK = 132,
	TKTX_VK_FORMAT_BC1_RGBA_UNORM_BLOCK = 133,
	TKTX_VK_FORMAT_BC1_RGBA_SRGB_BLOCK = 134,
	TKTX_VK_FORMAT_BC2_UNORM_BLOCK = 135,
	TKTX_VK_FORMAT_BC2_SRGB_BLOCK = 136,
	TKTX_VK_FORMAT_BC3_UNORM_BLOCK = 137,
	TKTX_VK_FORMAT_BC3_SRGB_BLOCK = 138,
	TKTX_VK_FORMAT_BC4_UNORM_BLOCK = 139,
	TKTX_VK_FORMAT_BC4_SNORM_BLOCK = 140,
	TKTX_VK_FORMAT_BC5_UNORM_BLOCK = 141,
	TKTX_VK_FORMAT_BC5_SNORM_BLOCK = 142,
	TKTX_VK_FORMAT_BC6H_UFLOAT_BLOCK = 143,
	TKTX_VK_FORMAT_BC6H_SFLOAT_BLOCK = 144,
	TKTX_VK_FORMAT_BC7_UNORM_BLOCK = 145,
	TKTX_VK_FORMAT_BC7_SRGB_BLOCK = 146,
	TKTX_VK_FORMAT_ETC2_R8G8B8_UNORM_BLOCK = 147,
	TKTX_VK_FORMAT_ETC2_R8G8B8_SRGB_BLOCK = 148,
	TKTX_VK_FORMAT_ETC2_R8G8B8A1_UNORM_BLOCK = 149,
	TKTX_VK_FORMAT_ETC2_R8G8B8A1_SRGB_BLOCK = 150,
	TKTX_VK_FORMAT_ETC2_R8G8B8A8_UNORM_BLOCK = 151,
	TKTX_VK_FORMAT_ETC2_R8G8B8A8_SRGB_BLOCK = 152,
	TKTX_VK_FORMAT_EAC_R11_UNORM_BLOCK = 153,
	TKTX_VK_FORMAT_EAC_R11_SNORM_BLOCK = 154,
	TKTX_VK_FORMAT_EAC_R11G11_UNORM_BLOCK = 155,
	TKTX_VK_FORMAT_EAC_R11G11_SNORM_BLOCK = 156,
	TKTX_VK_FORMAT_ASTC_4x4_UNORM_BLOCK = 157,
	TKTX_VK_FORMAT_ASTC_4x4_SRGB_BLOCK = 158,
	TKTX_VK_FORMAT_ASTC_5x4_UNORM_BLOCK = 159,
	TKTX_VK_FORMAT_ASTC_5x4_SRGB_BLOCK = 160,
	TKTX_VK_FORMAT_ASTC_5x5_UNORM_BLOCK = 161,
	TKTX_VK_FORMAT_ASTC_5x5_SRGB_BLOCK = 162,
	TKTX_VK_FORMAT_ASTC_6x5_UNORM_BLOCK = 163,
	TKTX_VK_FORMAT_ASTC_6x5_SRGB_BLOCK = 164,
	TKTX_VK_FORMAT_ASTC_6x6_UNORM_BLOCK = 165,
	TKTX_VK_FORMAT_ASTC_6x6_SRGB_BLOCK = 166,
	TKTX_VK_FORMAT_ASTC_8x5_UNORM_BLOCK = 167,
	TKTX_VK_FORMAT_ASTC_8x5_SRGB_BLOCK = 168,
	TKTX_VK_FORMAT_ASTC_8x6_UNORM_BLOCK = 169,
	TKTX_VK_FORMAT_ASTC_8x6_SRGB_BLOCK = 170,
	TKTX_VK_FORMAT_ASTC_8x8_UNORM_BLOCK = 171,
	TKTX_VK_FORMAT_ASTC_8x8_SRGB_BLOCK = 172,
	TKTX_VK_FORMAT_ASTC_10x5_UNORM_BLOCK = 173,
	TKTX_VK_FORMAT_ASTC_10x5_SRGB_BLOCK = 174,
	TKTX_VK_FORMAT_ASTC_10x6_UNORM_BLOCK = 175,
	TKTX_VK_FORMAT_ASTC_10x6_SRGB_BLOCK = 176,
	TKTX_VK_FORMAT_ASTC_10x8_UNORM_BLOCK = 177,
	TKTX_VK_FORMAT_ASTC_10x8_SRGB_BLOCK = 178,
	TKTX_VK_FORMAT_ASTC_10x10_UNORM_BLOCK = 179,
	TKTX_VK_FORMAT_ASTC_10x10_SRGB_BLOCK = 180,
	TKTX_VK_FORMAT_ASTC_12x10_UNORM_BLOCK = 181,
	TKTX_VK_FORMAT_ASTC_12x10_SRGB_BLOCK = 182,
	TKTX_VK_FORMAT_ASTC_12x12_UNORM_BLOCK = 183,
	TKTX_VK_FORMAT_ASTC_12x12_SRGB_BLOCK = 184,

	TKTX_VK_FORMAT_G8B8G8R8_422_UNORM = 1000156000,
	TKTX_VK_FORMAT_B8G8R8G8_422_UNORM = 1000156001,
	TKTX_VK_FORMAT_G8_B8_R8_3PLANE_420_UNORM = 1000156002,
	TKTX_VK_FORMAT_G8_B8R8_2PLANE_420_UNORM = 1000156003,
	TKTX_VK_FORMAT_G8_B8_R8_3PLANE_422_UNORM = 1000156004,
	TKTX_VK_FORMAT_G8_B8R8_2PLANE_422_UNORM = 1000156005,
	TKTX_VK_FORMAT_G8_B8_R8_3PLANE_444_UNORM = 1000156006,
	TKTX_VK_FORMAT_R10X6_UNORM_PACK16 = 1000156007,
	TKTX_VK_FORMAT_R10X6G10X6_UNORM_2PACK16 = 1000156008,
	TKTX_VK_FORMAT_R10X6G10X6B10X6A10X6_UNORM_4PACK16 = 1000156009,
	TKTX_VK_FORMAT_G10X6B10X6G10X6R10X6_422_UNORM_4PACK16 = 1000156010,
	TKTX_VK_FORMAT_B10X6G10X6R10X6G10X6_422_UNORM_4PACK16 = 1000156011,
	TKTX_VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_420_UNORM_3PACK16 = 1000156012,
	TKTX_VK_FORMAT_G10X6_B10X6R10X6_2PLANE_420_UNORM_3PACK16 = 1000156013,
	TKTX_VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_422_UNORM_3PACK16 = 1000156014,
	TKTX_VK_FORMAT_G10X6_B10X6R10X6_2PLANE_422_UNORM_3PACK16 = 1000156015,
	TKTX_VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_444_UNORM_3PACK16 = 1000156016,
	TKTX_VK_FORMAT_R12X4_UNORM_PACK16 = 1000156017,
	TKTX_VK_FORMAT_R12X4G12X4_UNORM_2PACK16 = 1000156018,
	TKTX_VK_FORMAT_R12X4G12X4B12X4A12X4_UNORM_4PACK16 = 1000156019,
	TKTX_VK_FORMAT_G12X4B12X4G12X4R12X4_422_UNORM_4PACK16 = 1000156020,
	TKTX_VK_FORMAT_B12X4G12X4R12X4G12X4_422_UNORM_4PACK16 = 1000156021,
	TKTX_VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_420_UNORM_3PACK16 = 1000156022,
	TKTX_VK_FORMAT_G12X4_B12X4R12X4_2PLANE_420_UNORM_3PACK16 = 1000156023,
	TKTX_VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_422_UNORM_3PACK16 = 1000156024,
	TKTX_VK_FORMAT_G12X4_B12X4R12X4_2PLANE_422_UNORM_3PACK16 = 1000156025,
	TKTX_VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_444_UNORM_3PACK16 = 1000156026,
	TKTX_VK_FORMAT_G16B16G16R16_422_UNORM = 1000156027,
	TKTX_VK_FORMAT_B16G16R16G16_422_UNORM = 1000156028,
	TKTX_VK_FORMAT_G16_B16_R16_3PLANE_420_UNORM = 1000156029,
	TKTX_VK_FORMAT_G16_B16R16_2PLANE_420_UNORM = 1000156030,
	TKTX_VK_FORMAT_G16_B16_R16_3PLANE_422_UNORM = 1000156031,
	TKTX_VK_FORMAT_G16_B16R16_2PLANE_422_UNORM = 1000156032,
	TKTX_VK_FORMAT_G16_B16_R16_3PLANE_444_UNORM = 1000156033,
	TKTX_VK_FORMAT_PVRTC1_2BPP_UNORM_BLOCK_IMG = 1000054000,
	TKTX_VK_FORMAT_PVRTC1_4BPP_UNORM_BLOCK_IMG = 1000054001,
	TKTX_VK_FORMAT_PVRTC2_2BPP_UNORM_BLOCK_IMG = 1000054002,
	TKTX_VK_FORMAT_PVRTC2_4BPP_UNORM_BLOCK_IMG = 1000054003,
	TKTX_VK_FORMAT_PVRTC1_2BPP_SRGB_BLOCK_IMG = 1000054004,
	TKTX_VK_FORMAT_PVRTC1_4BPP_SRGB_BLOCK_IMG = 1000054005,
	TKTX_VK_FORMAT_PVRTC2_2BPP_SRGB_BLOCK_IMG = 1000054006,
	TKTX_VK_FORMAT_PVRTC2_4BPP_SRGB_BLOCK_IMG = 1000054007,
} TinyKTX_VkFormat;

#define TINYKTX_MEV(x) TKTX_##x = TKTX_VK_FORMAT_##x
typedef enum TinyKtx_Format {
	TINYKTX_MEV(UNDEFINED),
	TINYKTX_MEV(R4G4_UNORM_PACK8),
	TINYKTX_MEV(R4G4B4A4_UNORM_PACK16),
	TINYKTX_MEV(B4G4R4A4_UNORM_PACK16),
	TINYKTX_MEV(R5G6B5_UNORM_PACK16),
	TINYKTX_MEV(B5G6R5_UNORM_PACK16),
	TINYKTX_MEV(R5G5B5A1_UNORM_PACK16),
	TINYKTX_MEV(B5G5R5A1_UNORM_PACK16),
	TINYKTX_MEV(A1R5G5B5_UNORM_PACK16),

	TINYKTX_MEV(R8_UNORM),
	TINYKTX_MEV(R8_SNORM),
	TINYKTX_MEV(R8_UINT),
	TINYKTX_MEV(R8_SINT),
	TINYKTX_MEV(R8_SRGB),

	TINYKTX_MEV(R8G8_UNORM),
	TINYKTX_MEV(R8G8_SNORM),
	TINYKTX_MEV(R8G8_UINT),
	TINYKTX_MEV(R8G8_SINT),
	TINYKTX_MEV(R8G8_SRGB),

	TINYKTX_MEV(R8G8B8_UNORM),
	TINYKTX_MEV(R8G8B8_SNORM),
	TINYKTX_MEV(R8G8B8_UINT),
	TINYKTX_MEV(R8G8B8_SINT),
	TINYKTX_MEV(R8G8B8_SRGB),
	TINYKTX_MEV(B8G8R8_UNORM),
	TINYKTX_MEV(B8G8R8_SNORM),
	TINYKTX_MEV(B8G8R8_UINT),
	TINYKTX_MEV(B8G8R8_SINT),
	TINYKTX_MEV(B8G8R8_SRGB),

	TINYKTX_MEV(R8G8B8A8_UNORM),
	TINYKTX_MEV(R8G8B8A8_SNORM),
	TINYKTX_MEV(R8G8B8A8_UINT),
	TINYKTX_MEV(R8G8B8A8_SINT),
	TINYKTX_MEV(R8G8B8A8_SRGB),
	TINYKTX_MEV(B8G8R8A8_UNORM),
	TINYKTX_MEV(B8G8R8A8_SNORM),
	TINYKTX_MEV(B8G8R8A8_UINT),
	TINYKTX_MEV(B8G8R8A8_SINT),
	TINYKTX_MEV(B8G8R8A8_SRGB),

	TINYKTX_MEV(A8B8G8R8_UNORM_PACK32),
	TINYKTX_MEV(A8B8G8R8_SNORM_PACK32),
	TINYKTX_MEV(A8B8G8R8_UINT_PACK32),
	TINYKTX_MEV(A8B8G8R8_SINT_PACK32),
	TINYKTX_MEV(A8B8G8R8_SRGB_PACK32),

	TINYKTX_MEV(E5B9G9R9_UFLOAT_PACK32),
	TINYKTX_MEV(A2R10G10B10_UNORM_PACK32),
	TINYKTX_MEV(A2R10G10B10_UINT_PACK32),
	TINYKTX_MEV(A2B10G10R10_UNORM_PACK32),
	TINYKTX_MEV(A2B10G10R10_UINT_PACK32),
	TINYKTX_MEV(B10G11R11_UFLOAT_PACK32),

	TINYKTX_MEV(R16_UNORM),
	TINYKTX_MEV(R16_SNORM),
	TINYKTX_MEV(R16_UINT),
	TINYKTX_MEV(R16_SINT),
	TINYKTX_MEV(R16_SFLOAT),
	TINYKTX_MEV(R16G16_UNORM),
	TINYKTX_MEV(R16G16_SNORM),
	TINYKTX_MEV(R16G16_UINT),
	TINYKTX_MEV(R16G16_SINT),
	TINYKTX_MEV(R16G16_SFLOAT),
	TINYKTX_MEV(R16G16B16_UNORM),
	TINYKTX_MEV(R16G16B16_SNORM),
	TINYKTX_MEV(R16G16B16_UINT),
	TINYKTX_MEV(R16G16B16_SINT),
	TINYKTX_MEV(R16G16B16_SFLOAT),
	TINYKTX_MEV(R16G16B16A16_UNORM),
	TINYKTX_MEV(R16G16B16A16_SNORM),
	TINYKTX_MEV(R16G16B16A16_UINT),
	TINYKTX_MEV(R16G16B16A16_SINT),
	TINYKTX_MEV(R16G16B16A16_SFLOAT),
	TINYKTX_MEV(R32_UINT),
	TINYKTX_MEV(R32_SINT),
	TINYKTX_MEV(R32_SFLOAT),
	TINYKTX_MEV(R32G32_UINT),
	TINYKTX_MEV(R32G32_SINT),
	TINYKTX_MEV(R32G32_SFLOAT),
	TINYKTX_MEV(R32G32B32_UINT),
	TINYKTX_MEV(R32G32B32_SINT),
	TINYKTX_MEV(R32G32B32_SFLOAT),
	TINYKTX_MEV(R32G32B32A32_UINT),
	TINYKTX_MEV(R32G32B32A32_SINT),
	TINYKTX_MEV(R32G32B32A32_SFLOAT),

	TINYKTX_MEV(BC1_RGB_UNORM_BLOCK),
	TINYKTX_MEV(BC1_RGB_SRGB_BLOCK),
	TINYKTX_MEV(BC1_RGBA_UNORM_BLOCK),
	TINYKTX_MEV(BC1_RGBA_SRGB_BLOCK),
	TINYKTX_MEV(BC2_UNORM_BLOCK),
	TINYKTX_MEV(BC2_SRGB_BLOCK),
	TINYKTX_MEV(BC3_UNORM_BLOCK),
	TINYKTX_MEV(BC3_SRGB_BLOCK),
	TINYKTX_MEV(BC4_UNORM_BLOCK),
	TINYKTX_MEV(BC4_SNORM_BLOCK),
	TINYKTX_MEV(BC5_UNORM_BLOCK),
	TINYKTX_MEV(BC5_SNORM_BLOCK),
	TINYKTX_MEV(BC6H_UFLOAT_BLOCK),
	TINYKTX_MEV(BC6H_SFLOAT_BLOCK),
	TINYKTX_MEV(BC7_UNORM_BLOCK),
	TINYKTX_MEV(BC7_SRGB_BLOCK),

	TINYKTX_MEV(ETC2_R8G8B8_UNORM_BLOCK),
	TINYKTX_MEV(ETC2_R8G8B8A1_UNORM_BLOCK),
	TINYKTX_MEV(ETC2_R8G8B8A8_UNORM_BLOCK),
	TINYKTX_MEV(ETC2_R8G8B8_SRGB_BLOCK),
	TINYKTX_MEV(ETC2_R8G8B8A1_SRGB_BLOCK),
	TINYKTX_MEV(ETC2_R8G8B8A8_SRGB_BLOCK),
	TINYKTX_MEV(EAC_R11_UNORM_BLOCK),
	TINYKTX_MEV(EAC_R11G11_UNORM_BLOCK),
	TINYKTX_MEV(EAC_R11_SNORM_BLOCK),
	TINYKTX_MEV(EAC_R11G11_SNORM_BLOCK),

	TKTX_PVR_2BPP_BLOCK = TKTX_VK_FORMAT_PVRTC1_2BPP_UNORM_BLOCK_IMG,
	TKTX_PVR_2BPPA_BLOCK = TKTX_VK_FORMAT_PVRTC2_2BPP_UNORM_BLOCK_IMG,
	TKTX_PVR_4BPP_BLOCK = TKTX_VK_FORMAT_PVRTC1_4BPP_UNORM_BLOCK_IMG,
	TKTX_PVR_4BPPA_BLOCK = TKTX_VK_FORMAT_PVRTC2_4BPP_UNORM_BLOCK_IMG,
	TKTX_PVR_2BPP_SRGB_BLOCK = TKTX_VK_FORMAT_PVRTC1_2BPP_SRGB_BLOCK_IMG,
	TKTX_PVR_2BPPA_SRGB_BLOCK = TKTX_VK_FORMAT_PVRTC2_2BPP_SRGB_BLOCK_IMG,
	TKTX_PVR_4BPP_SRGB_BLOCK = TKTX_VK_FORMAT_PVRTC1_4BPP_SRGB_BLOCK_IMG,
	TKTX_PVR_4BPPA_SRGB_BLOCK = TKTX_VK_FORMAT_PVRTC2_4BPP_SRGB_BLOCK_IMG,

	TINYKTX_MEV(ASTC_4x4_UNORM_BLOCK),
	TINYKTX_MEV(ASTC_4x4_SRGB_BLOCK),
	TINYKTX_MEV(ASTC_5x4_UNORM_BLOCK),
	TINYKTX_MEV(ASTC_5x4_SRGB_BLOCK),
	TINYKTX_MEV(ASTC_5x5_UNORM_BLOCK),
	TINYKTX_MEV(ASTC_5x5_SRGB_BLOCK),
	TINYKTX_MEV(ASTC_6x5_UNORM_BLOCK),
	TINYKTX_MEV(ASTC_6x5_SRGB_BLOCK),
	TINYKTX_MEV(ASTC_6x6_UNORM_BLOCK),
	TINYKTX_MEV(ASTC_6x6_SRGB_BLOCK),
	TINYKTX_MEV(ASTC_8x5_UNORM_BLOCK),
	TINYKTX_MEV(ASTC_8x5_SRGB_BLOCK),
	TINYKTX_MEV(ASTC_8x6_UNORM_BLOCK),
	TINYKTX_MEV(ASTC_8x6_SRGB_BLOCK),
	TINYKTX_MEV(ASTC_8x8_UNORM_BLOCK),
	TINYKTX_MEV(ASTC_8x8_SRGB_BLOCK),
	TINYKTX_MEV(ASTC_10x5_UNORM_BLOCK),
	TINYKTX_MEV(ASTC_10x5_SRGB_BLOCK),
	TINYKTX_MEV(ASTC_10x6_UNORM_BLOCK),
	TINYKTX_MEV(ASTC_10x6_SRGB_BLOCK),
	TINYKTX_MEV(ASTC_10x8_UNORM_BLOCK),
	TINYKTX_MEV(ASTC_10x8_SRGB_BLOCK),
	TINYKTX_MEV(ASTC_10x10_UNORM_BLOCK),
	TINYKTX_MEV(ASTC_10x10_SRGB_BLOCK),
	TINYKTX_MEV(ASTC_12x10_UNORM_BLOCK),
	TINYKTX_MEV(ASTC_12x10_SRGB_BLOCK),
	TINYKTX_MEV(ASTC_12x12_UNORM_BLOCK),
	TINYKTX_MEV(ASTC_12x12_SRGB_BLOCK),

} TinyKtx_Format;
#undef TINYKTX_MEV

TinyKtx_Format TinyKtx_GetFormat(TinyKtx_ContextHandle handle);
bool TinyKtx_CrackFormatToGL(TinyKtx_Format format, uint32_t *glformat, uint32_t *gltype, uint32_t *glinternalformat, uint32_t* typesize);
bool TinyKtx_WriteImage(TinyKtx_WriteCallbacks const *callbacks,
												void *user,
												uint32_t width,
												uint32_t height,
												uint32_t depth,
												uint32_t slices,
												uint32_t mipmaplevels,
												TinyKtx_Format format,
												bool cubemap,
												uint32_t const *mipmapsizes,
												void const **mipmaps);
// GL types
#define TINYKTX_GL_TYPE_COMPRESSED                      0x0
#define TINYKTX_GL_TYPE_BYTE                            0x1400
#define TINYKTX_GL_TYPE_UNSIGNED_BYTE                    0x1401
#define TINYKTX_GL_TYPE_SHORT                            0x1402
#define TINYKTX_GL_TYPE_UNSIGNED_SHORT                  0x1403
#define TINYKTX_GL_TYPE_INT                              0x1404
#define TINYKTX_GL_TYPE_UNSIGNED_INT                    0x1405
#define TINYKTX_GL_TYPE_FLOAT                            0x1406
#define TINYKTX_GL_TYPE_DOUBLE                          0x140A
#define TINYKTX_GL_TYPE_HALF_FLOAT                      0x140B
#define TINYKTX_GL_TYPE_UNSIGNED_BYTE_3_3_2              0x8032
#define TINYKTX_GL_TYPE_UNSIGNED_SHORT_4_4_4_4          0x8033
#define TINYKTX_GL_TYPE_UNSIGNED_SHORT_5_5_5_1          0x8034
#define TINYKTX_GL_TYPE_UNSIGNED_INT_8_8_8_8            0x8035
#define TINYKTX_GL_TYPE_UNSIGNED_INT_10_10_10_2          0x8036
#define TINYKTX_GL_TYPE_UNSIGNED_BYTE_2_3_3_REV          0x8362
#define TINYKTX_GL_TYPE_UNSIGNED_SHORT_5_6_5            0x8363
#define TINYKTX_GL_TYPE_UNSIGNED_SHORT_5_6_5_REV        0x8364
#define TINYKTX_GL_TYPE_UNSIGNED_SHORT_4_4_4_4_REV      0x8365
#define TINYKTX_GL_TYPE_UNSIGNED_SHORT_1_5_5_5_REV      0x8366
#define TINYKTX_GL_TYPE_UNSIGNED_INT_8_8_8_8_REV        0x8367
#define TINYKTX_GL_TYPE_UNSIGNED_INT_2_10_10_10_REV      0x8368
#define TINYKTX_GL_TYPE_UNSIGNED_INT_24_8                0x84FA
#define TINYKTX_GL_TYPE_UNSIGNED_INT_5_9_9_9_REV        0x8C3E
#define TINYKTX_GL_TYPE_UNSIGNED_INT_10F_11F_11F_REV    0x8C3B
#define TINYKTX_GL_TYPE_FLOAT_32_UNSIGNED_INT_24_8_REV  0x8DAD

// formats
#define TINYKTX_GL_FORMAT_RED                              0x1903
#define TINYKTX_GL_FORMAT_GREEN                            0x1904
#define TINYKTX_GL_FORMAT_BLUE                            0x1905
#define TINYKTX_GL_FORMAT_ALPHA                            0x1906
#define TINYKTX_GL_FORMAT_RGB                              0x1907
#define TINYKTX_GL_FORMAT_RGBA                            0x1908
#define TINYKTX_GL_FORMAT_LUMINANCE                        0x1909
#define TINYKTX_GL_FORMAT_LUMINANCE_ALPHA                  0x190A
#define TINYKTX_GL_FORMAT_ABGR                            0x8000
#define TINYKTX_GL_FORMAT_INTENSITY                        0x8049
#define TINYKTX_GL_FORMAT_BGR                              0x80E0
#define TINYKTX_GL_FORMAT_BGRA                            0x80E1
#define TINYKTX_GL_FORMAT_RG                              0x8227
#define TINYKTX_GL_FORMAT_RG_INTEGER                      0x8228
#define TINYKTX_GL_FORMAT_SRGB                            0x8C40
#define TINYKTX_GL_FORMAT_SRGB_ALPHA                      0x8C42
#define TINYKTX_GL_FORMAT_SLUMINANCE_ALPHA                0x8C44
#define TINYKTX_GL_FORMAT_SLUMINANCE                      0x8C46
#define TINYKTX_GL_FORMAT_RED_INTEGER                      0x8D94
#define TINYKTX_GL_FORMAT_GREEN_INTEGER                    0x8D95
#define TINYKTX_GL_FORMAT_BLUE_INTEGER                    0x8D96
#define TINYKTX_GL_FORMAT_ALPHA_INTEGER                    0x8D97
#define TINYKTX_GL_FORMAT_RGB_INTEGER                      0x8D98
#define TINYKTX_GL_FORMAT_RGBA_INTEGER                    0x8D99
#define TINYKTX_GL_FORMAT_BGR_INTEGER                      0x8D9A
#define TINYKTX_GL_FORMAT_BGRA_INTEGER                    0x8D9B
#define TINYKTX_GL_FORMAT_RED_SNORM                        0x8F90
#define TINYKTX_GL_FORMAT_RG_SNORM                        0x8F91
#define TINYKTX_GL_FORMAT_RGB_SNORM                        0x8F92
#define TINYKTX_GL_FORMAT_RGBA_SNORM                      0x8F93

#define TINYKTX_GL_INTFORMAT_ALPHA4                          0x803B
#define TINYKTX_GL_INTFORMAT_ALPHA8                          0x803C
#define TINYKTX_GL_INTFORMAT_ALPHA12                          0x803D
#define TINYKTX_GL_INTFORMAT_ALPHA16                          0x803E
#define TINYKTX_GL_INTFORMAT_LUMINANCE4                      0x803F
#define TINYKTX_GL_INTFORMAT_LUMINANCE8                      0x8040
#define TINYKTX_GL_INTFORMAT_LUMINANCE12                      0x8041
#define TINYKTX_GL_INTFORMAT_LUMINANCE16                      0x8042
#define TINYKTX_GL_INTFORMAT_LUMINANCE4_ALPHA4                0x8043
#define TINYKTX_GL_INTFORMAT_LUMINANCE6_ALPHA2                0x8044
#define TINYKTX_GL_INTFORMAT_LUMINANCE8_ALPHA8                0x8045
#define TINYKTX_GL_INTFORMAT_LUMINANCE12_ALPHA4              0x8046
#define TINYKTX_GL_INTFORMAT_LUMINANCE12_ALPHA12              0x8047
#define TINYKTX_GL_INTFORMAT_LUMINANCE16_ALPHA16              0x8048
#define TINYKTX_GL_INTFORMAT_INTENSITY4                      0x804A
#define TINYKTX_GL_INTFORMAT_INTENSITY8                      0x804B
#define TINYKTX_GL_INTFORMAT_INTENSITY12                      0x804C
#define TINYKTX_GL_INTFORMAT_INTENSITY16                      0x804D
#define TINYKTX_GL_INTFORMAT_RGB2                            0x804E
#define TINYKTX_GL_INTFORMAT_RGB4                            0x804F
#define TINYKTX_GL_INTFORMAT_RGB5                            0x8050
#define TINYKTX_GL_INTFORMAT_RGB8                              0x8051
#define TINYKTX_GL_INTFORMAT_RGB10                            0x8052
#define TINYKTX_GL_INTFORMAT_RGB12                            0x8053
#define TINYKTX_GL_INTFORMAT_RGB16                            0x8054
#define TINYKTX_GL_INTFORMAT_RGBA2                            0x8055
#define TINYKTX_GL_INTFORMAT_RGBA4                            0x8056
#define TINYKTX_GL_INTFORMAT_RGB5_A1                          0x8057
#define TINYKTX_GL_INTFORMAT_RGBA8                            0x8058
#define TINYKTX_GL_INTFORMAT_RGB10_A2                        0x8059
#define TINYKTX_GL_INTFORMAT_RGBA12                          0x805A
#define TINYKTX_GL_INTFORMAT_RGBA16                          0x805B
#define TINYKTX_GL_INTFORMAT_R8                              0x8229
#define TINYKTX_GL_INTFORMAT_R16                              0x822A
#define TINYKTX_GL_INTFORMAT_RG8                              0x822B
#define TINYKTX_GL_INTFORMAT_RG16                            0x822C
#define TINYKTX_GL_INTFORMAT_R16F                            0x822D
#define TINYKTX_GL_INTFORMAT_R32F                            0x822E
#define TINYKTX_GL_INTFORMAT_RG16F                            0x822F
#define TINYKTX_GL_INTFORMAT_RG32F                            0x8230
#define TINYKTX_GL_INTFORMAT_R8I                              0x8231
#define TINYKTX_GL_INTFORMAT_R8UI                            0x8232
#define TINYKTX_GL_INTFORMAT_R16I                            0x8233
#define TINYKTX_GL_INTFORMAT_R16UI                            0x8234
#define TINYKTX_GL_INTFORMAT_R32I                            0x8235
#define TINYKTX_GL_INTFORMAT_R32UI                            0x8236
#define TINYKTX_GL_INTFORMAT_RG8I                            0x8237
#define TINYKTX_GL_INTFORMAT_RG8UI                            0x8238
#define TINYKTX_GL_INTFORMAT_RG16I                            0x8239
#define TINYKTX_GL_INTFORMAT_RG16UI                          0x823A
#define TINYKTX_GL_INTFORMAT_RG32I                            0x823B
#define TINYKTX_GL_INTFORMAT_RG32UI                          0x823C
#define TINYKTX_GL_INTFORMAT_RGBA32F                          0x8814
#define TINYKTX_GL_INTFORMAT_RGB32F                          0x8815
#define TINYKTX_GL_INTFORMAT_RGBA16F                          0x881A
#define TINYKTX_GL_INTFORMAT_RGB16F                          0x881B
#define TINYKTX_GL_INTFORMAT_R11F_G11F_B10F                  0x8C3A
#define TINYKTX_GL_INTFORMAT_UNSIGNED_INT_10F_11F_11F_REV      0x8C3B
#define TINYKTX_GL_INTFORMAT_RGB9_E5                          0x8C3D
#define TINYKTX_GL_INTFORMAT_SRGB8                            0x8C41
#define TINYKTX_GL_INTFORMAT_SRGB8_ALPHA8                      0x8C43
#define TINYKTX_GL_INTFORMAT_SLUMINANCE8_ALPHA8              0x8C45
#define TINYKTX_GL_INTFORMAT_SLUMINANCE8                      0x8C47
#define TINYKTX_GL_INTFORMAT_RGB565                          0x8D62
#define TINYKTX_GL_INTFORMAT_RGBA32UI                        0x8D70
#define TINYKTX_GL_INTFORMAT_RGB32UI                          0x8D71
#define TINYKTX_GL_INTFORMAT_RGBA16UI                        0x8D76
#define TINYKTX_GL_INTFORMAT_RGB16UI                          0x8D77
#define TINYKTX_GL_INTFORMAT_RGBA8UI                          0x8D7C
#define TINYKTX_GL_INTFORMAT_RGB8UI                          0x8D7D
#define TINYKTX_GL_INTFORMAT_RGBA32I                          0x8D82
#define TINYKTX_GL_INTFORMAT_RGB32I                          0x8D83
#define TINYKTX_GL_INTFORMAT_RGBA16I                          0x8D88
#define TINYKTX_GL_INTFORMAT_RGB16I                          0x8D89
#define TINYKTX_GL_INTFORMAT_RGBA8I                          0x8D8E
#define TINYKTX_GL_INTFORMAT_RGB8I                            0x8D8F
#define TINYKTX_GL_INTFORMAT_FLOAT_32_UNSIGNED_INT_24_8_REV  0x8DAD
#define TINYKTX_GL_INTFORMAT_R8_SNORM                        0x8F94
#define TINYKTX_GL_INTFORMAT_RG8_SNORM                        0x8F95
#define TINYKTX_GL_INTFORMAT_RGB8_SNORM                      0x8F96
#define TINYKTX_GL_INTFORMAT_RGBA8_SNORM                      0x8F97
#define TINYKTX_GL_INTFORMAT_R16_SNORM                        0x8F98
#define TINYKTX_GL_INTFORMAT_RG16_SNORM                      0x8F99
#define TINYKTX_GL_INTFORMAT_RGB16_SNORM                      0x8F9A
#define TINYKTX_GL_INTFORMAT_RGBA16_SNORM                    0x8F9B
#define TINYKTX_GL_INTFORMAT_ALPHA8_SNORM                    0x9014
#define TINYKTX_GL_INTFORMAT_LUMINANCE8_SNORM                0x9015
#define TINYKTX_GL_INTFORMAT_LUMINANCE8_ALPHA8_SNORM          0x9016
#define TINYKTX_GL_INTFORMAT_INTENSITY8_SNORM                0x9017
#define TINYKTX_GL_INTFORMAT_ALPHA16_SNORM                    0x9018
#define TINYKTX_GL_INTFORMAT_LUMINANCE16_SNORM                0x9019
#define TINYKTX_GL_INTFORMAT_LUMINANCE16_ALPHA16_SNORM        0x901A
#define TINYKTX_GL_INTFORMAT_INTENSITY16_SNORM                0x901B

#define TINYKTX_GL_PALETTE4_RGB8_OES              0x8B90
#define TINYKTX_GL_PALETTE4_RGBA8_OES             0x8B91
#define TINYKTX_GL_PALETTE4_R5_G6_B5_OES          0x8B92
#define TINYKTX_GL_PALETTE4_RGBA4_OES             0x8B93
#define TINYKTX_GL_PALETTE4_RGB5_A1_OES           0x8B94
#define TINYKTX_GL_PALETTE8_RGB8_OES              0x8B95
#define TINYKTX_GL_PALETTE8_RGBA8_OES             0x8B96
#define TINYKTX_GL_PALETTE8_R5_G6_B5_OES          0x8B97
#define TINYKTX_GL_PALETTE8_RGBA4_OES             0x8B98
#define TINYKTX_GL_PALETTE8_RGB5_A1_OES           0x8B99

// compressed formats

#define TINYKTX_GL_COMPRESSED_RGB_S3TC_DXT1                  	0x83F0
#define TINYKTX_GL_COMPRESSED_RGBA_S3TC_DXT1                  0x83F1
#define TINYKTX_GL_COMPRESSED_RGBA_S3TC_DXT3                  0x83F2
#define TINYKTX_GL_COMPRESSED_RGBA_S3TC_DXT5                  0x83F3
#define TINYKTX_GL_COMPRESSED_3DC_X_AMD                       0x87F9
#define TINYKTX_GL_COMPRESSED_3DC_XY_AMD                      0x87FA
#define TINYKTX_GL_COMPRESSED_ATC_RGBA_INTERPOLATED_ALPHA    	0x87EE
#define TINYKTX_GL_COMPRESSED_SRGB_PVRTC_2BPPV1               0x8A54
#define TINYKTX_GL_COMPRESSED_SRGB_PVRTC_4BPPV1               0x8A55
#define TINYKTX_GL_COMPRESSED_SRGB_ALPHA_PVRTC_2BPPV1         0x8A56
#define TINYKTX_GL_COMPRESSED_SRGB_ALPHA_PVRTC_4BPPV1         0x8A57
#define TINYKTX_GL_COMPRESSED_RGB_PVRTC_4BPPV1                0x8C00
#define TINYKTX_GL_COMPRESSED_RGB_PVRTC_2BPPV1                0x8C01
#define TINYKTX_GL_COMPRESSED_RGBA_PVRTC_4BPPV1               0x8C02
#define TINYKTX_GL_COMPRESSED_RGBA_PVRTC_2BPPV1               0x8C03
#define TINYKTX_GL_COMPRESSED_SRGB_S3TC_DXT1                  0x8C4C
#define TINYKTX_GL_COMPRESSED_SRGB_ALPHA_S3TC_DXT1            0x8C4D
#define TINYKTX_GL_COMPRESSED_SRGB_ALPHA_S3TC_DXT3            0x8C4E
#define TINYKTX_GL_COMPRESSED_SRGB_ALPHA_S3TC_DXT5            0x8C4F
#define TINYKTX_GL_COMPRESSED_LUMINANCE_LATC1                	0x8C70
#define TINYKTX_GL_COMPRESSED_SIGNED_LUMINANCE_LATC1          0x8C71
#define TINYKTX_GL_COMPRESSED_LUMINANCE_ALPHA_LATC2           0x8C72
#define TINYKTX_GL_COMPRESSED_SIGNED_LUMINANCE_ALPHA_LATC2    0x8C73
#define TINYKTX_GL_COMPRESSED_ATC_RGB                         0x8C92
#define TINYKTX_GL_COMPRESSED_ATC_RGBA_EXPLICIT_ALPHA         0x8C93
#define TINYKTX_GL_COMPRESSED_RED_RGTC1                       0x8DBB
#define TINYKTX_GL_COMPRESSED_SIGNED_RED_RGTC1                0x8DBC
#define TINYKTX_GL_COMPRESSED_RED_GREEN_RGTC2                	0x8DBD
#define TINYKTX_GL_COMPRESSED_SIGNED_RED_GREEN_RGTC2          0x8DBE
#define TINYKTX_GL_COMPRESSED_ETC1_RGB8_OES                   0x8D64
#define TINYKTX_GL_COMPRESSED_RGBA_BPTC_UNORM                	0x8E8C
#define TINYKTX_GL_COMPRESSED_SRGB_ALPHA_BPTC_UNORM          	0x8E8D
#define TINYKTX_GL_COMPRESSED_RGB_BPTC_SIGNED_FLOAT          	0x8E8E
#define TINYKTX_GL_COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT        	0x8E8F
#define TINYKTX_GL_COMPRESSED_R11_EAC                        	0x9270
#define TINYKTX_GL_COMPRESSED_SIGNED_R11_EAC                  0x9271
#define TINYKTX_GL_COMPRESSED_RG11_EAC                        0x9272
#define TINYKTX_GL_COMPRESSED_SIGNED_RG11_EAC                	0x9273
#define TINYKTX_GL_COMPRESSED_RGB8_ETC2                      	0x9274
#define TINYKTX_GL_COMPRESSED_SRGB8_ETC2                      0x9275
#define TINYKTX_GL_COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2   0x9276
#define TINYKTX_GL_COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2  0x9277
#define TINYKTX_GL_COMPRESSED_RGBA8_ETC2_EAC                  0x9278
#define TINYKTX_GL_COMPRESSED_SRGB8_ALPHA8_ETC2_EAC           0x9279
#define TINYKTX_GL_COMPRESSED_SRGB_ALPHA_PVRTC_2BPPV2         0x93F0
#define TINYKTX_GL_COMPRESSED_SRGB_ALPHA_PVRTC_4BPPV2         0x93F1
#define TINYKTX_GL_COMPRESSED_RGBA_ASTC_4x4		   							0x93B0
#define TINYKTX_GL_COMPRESSED_RGBA_ASTC_5x4		              	0x93B1
#define TINYKTX_GL_COMPRESSED_RGBA_ASTC_5x5		              	0x93B2
#define TINYKTX_GL_COMPRESSED_RGBA_ASTC_6x5		              	0x93B3
#define TINYKTX_GL_COMPRESSED_RGBA_ASTC_6x6		              	0x93B4
#define TINYKTX_GL_COMPRESSED_RGBA_ASTC_8x5		              	0x93B5
#define TINYKTX_GL_COMPRESSED_RGBA_ASTC_8x6		              	0x93B6
#define TINYKTX_GL_COMPRESSED_RGBA_ASTC_8x8		              	0x93B7
#define TINYKTX_GL_COMPRESSED_RGBA_ASTC_10x5		              0x93B8
#define TINYKTX_GL_COMPRESSED_RGBA_ASTC_10x6		              0x93B9
#define TINYKTX_GL_COMPRESSED_RGBA_ASTC_10x8		              0x93BA
#define TINYKTX_GL_COMPRESSED_RGBA_ASTC_10x10	            		0x93BB
#define TINYKTX_GL_COMPRESSED_RGBA_ASTC_12x10	            		0x93BC
#define TINYKTX_GL_COMPRESSED_RGBA_ASTC_12x12	            		0x93BD
#define TINYKTX_GL_COMPRESSED_SRGB8_ALPHA8_ASTC_4x4			      0x93D0
#define TINYKTX_GL_COMPRESSED_SRGB8_ALPHA8_ASTC_5x4			      0x93D1
#define TINYKTX_GL_COMPRESSED_SRGB8_ALPHA8_ASTC_5x5			      0x93D2
#define TINYKTX_GL_COMPRESSED_SRGB8_ALPHA8_ASTC_6x5						0x93D3
#define TINYKTX_GL_COMPRESSED_SRGB8_ALPHA8_ASTC_6x6						0x93D4
#define TINYKTX_GL_COMPRESSED_SRGB8_ALPHA8_ASTC_8x5						0x93D5
#define TINYKTX_GL_COMPRESSED_SRGB8_ALPHA8_ASTC_8x6						0x93D6
#define TINYKTX_GL_COMPRESSED_SRGB8_ALPHA8_ASTC_8x8						0x93D7
#define TINYKTX_GL_COMPRESSED_SRGB8_ALPHA8_ASTC_10x5					0x93D8
#define TINYKTX_GL_COMPRESSED_SRGB8_ALPHA8_ASTC_10x6					0x93D9
#define TINYKTX_GL_COMPRESSED_SRGB8_ALPHA8_ASTC_10x8					0x93DA
#define TINYKTX_GL_COMPRESSED_SRGB8_ALPHA8_ASTC_10x10					0x93DB
#define TINYKTX_GL_COMPRESSED_SRGB8_ALPHA8_ASTC_12x10     		0x93DC
#define TINYKTX_GL_COMPRESSED_SRGB8_ALPHA8_ASTC_12x12     		0x93DD

#ifdef TINYKTX_IMPLEMENTATION

typedef struct TinyKtx_Header {
	uint8_t identifier[12];
	uint32_t endianness;
	uint32_t glType;
	uint32_t glTypeSize;
	uint32_t glFormat;
	uint32_t glInternalFormat;
	uint32_t glBaseInternalFormat;
	uint32_t pixelWidth;
	uint32_t pixelHeight;
	uint32_t pixelDepth;
	uint32_t numberOfArrayElements;
	uint32_t numberOfFaces;
	uint32_t numberOfMipmapLevels;
	uint32_t bytesOfKeyValueData;

} TinyKtx_Header;

typedef struct TinyKtx_KeyValuePair {
	uint32_t size;
} TinyKtx_KeyValuePair; // followed by at least size bytes (aligned to 4)

#ifdef TINY_KTX_EXPERIMENTAL_KTX2_SUPPORT
typedef struct TinyKtx_HeaderV2 {
	uint8_t identifier[12];
	TinyKtx_Format vkFormat;
	uint32_t pixelWidth;
	uint32_t pixelHeight;
	uint32_t pixelDepth;
	uint32_t arrayElementCount;
	uint32_t faceCount;
	uint32_t levelCount;
	uint32_t supercompressionScheme;

	uint32_t dfdByteOffset;
	uint32_t dfdByteLength;
	uint32_t kvdByteOffset;
	uint32_t kvdByteLength;
	uint64_t sgdByteOffset;
	uint64_t sgdByteLength;
} TinyKtx_HeaderV2;

typedef struct TinyKtx_LevelV2 {
	uint64_t byteOffset;
	uint64_t byteLength;
	uint64_t uncompressedByteLength;
} TinyKtx_LevelV2;

typedef enum TinyKtx_SuperCompressionScheme {
	TKTX_SUPERCOMPRESSION_NONE = 0,
	TKTX_SUPERCOMPRESSION_CRN = 1,
	TKTX_SUPERCOMPRESSION_ZLIB = 2,
	TKTX_SUPERCOMPRESSION_ZSTD = 3,
} TinyKtx_SuperCompressionScheme;
#endif // end V2 support

typedef struct TinyKtx_Context {
	TinyKtx_Callbacks callbacks;
	void *user;
	uint64_t headerPos;
	uint64_t firstImagePos;

	union {
		TinyKtx_Header header;
#ifdef TINY_KTX_EXPERIMENTAL_KTX2_SUPPORT
		TinyKtx_HeaderV2 headerV2;
#endif
	};

	TinyKtx_KeyValuePair const *keyData;
	bool headerValid;
	bool sameEndian;
#ifdef TINY_KTX_EXPERIMENTAL_KTX2_SUPPORT
	bool v2;
	void* sgdData;
#endif
	union {
#ifdef TINY_KTX_EXPERIMENTAL_KTX2_SUPPORT
		TinyKtx_LevelV2 levels[TINYKTX_MAX_MIPMAPLEVELS];
#endif
		uint32_t mipMapSizes[TINYKTX_MAX_MIPMAPLEVELS];
	};

	uint8_t const *mipmaps[TINYKTX_MAX_MIPMAPLEVELS];

} TinyKtx_Context;

static uint8_t TinyKtx_fileIdentifier[12] = {
		0xAB, 0x4B, 0x54, 0x58, 0x20, 0x31, 0x31, 0xBB, 0x0D, 0x0A, 0x1A, 0x0A
};

#ifdef TINY_KTX_EXPERIMENTAL_KTX2_SUPPORT
static uint8_t TinyKtx_fileIdentifierV2[12] = {
		0xAB, 0x4B, 0x54, 0x58, 0x20, 0x32, 0x30, 0xBB, 0x0D, 0x0A, 0x1A, 0x0A
};
#endif

static void TinyKtx_NullErrorFunc(void *user, char const *msg) {}

TinyKtx_ContextHandle TinyKtx_CreateContext(TinyKtx_Callbacks const *callbacks, void *user) {
	TinyKtx_Context *ctx = (TinyKtx_Context *) callbacks->alloc(user, sizeof(TinyKtx_Context));
	if (ctx == NULL)
		return NULL;

	memset(ctx, 0, sizeof(TinyKtx_Context));
	memcpy(&ctx->callbacks, callbacks, sizeof(TinyKtx_Callbacks));
	ctx->user = user;
	if (ctx->callbacks.error == NULL) {
		ctx->callbacks.error = &TinyKtx_NullErrorFunc;
	}

	if (ctx->callbacks.read == NULL) {
		ctx->callbacks.error(user, "TinyKtx must have read callback");
		return NULL;
	}
	if (ctx->callbacks.alloc == NULL) {
		ctx->callbacks.error(user, "TinyKtx must have alloc callback");
		return NULL;
	}
	if (ctx->callbacks.free == NULL) {
		ctx->callbacks.error(user, "TinyKtx must have free callback");
		return NULL;
	}
	if (ctx->callbacks.seek == NULL) {
		ctx->callbacks.error(user, "TinyKtx must have seek callback");
		return NULL;
	}
	if (ctx->callbacks.tell == NULL) {
		ctx->callbacks.error(user, "TinyKtx must have tell callback");
		return NULL;
	}

	TinyKtx_Reset(ctx);

	return ctx;
}

void TinyKtx_DestroyContext(TinyKtx_ContextHandle handle) {
	TinyKtx_Context *ctx = (TinyKtx_Context *) handle;
	if (ctx == NULL)
		return;
	TinyKtx_Reset(handle);

	ctx->callbacks.free(ctx->user, ctx);
}

void TinyKtx_Reset(TinyKtx_ContextHandle handle) {
	TinyKtx_Context *ctx = (TinyKtx_Context *) handle;
	if (ctx == NULL)
		return;

	// backup user provided callbacks and data
	TinyKtx_Callbacks callbacks;
	memcpy(&callbacks, &ctx->callbacks, sizeof(TinyKtx_Callbacks));
	void *user = ctx->user;

#ifdef TINY_KTX_EXPERIMENTAL_KTX2_SUPPORT
	// free any super compression global data we've allocated
	if (ctx->sgdData != NULL) {
		callbacks.free(user, (void *) ctx->sgdData);
	}
#endif

	// free memory of sub data
	if (ctx->keyData != NULL) {
		callbacks.free(user, (void *) ctx->keyData);
	}

	for (int i = 0; i < TINYKTX_MAX_MIPMAPLEVELS; ++i) {
		if (ctx->mipmaps[i] != NULL) {
			callbacks.free(user, (void *) ctx->mipmaps[i]);
		}
	}

	// reset to default state
	memset(ctx, 0, sizeof(TinyKtx_Context));
	memcpy(&ctx->callbacks, &callbacks, sizeof(TinyKtx_Callbacks));
	ctx->user = user;

}


#ifdef TINY_KTX_EXPERIMENTAL_KTX2_SUPPORT
bool TinyKtx_ReadHeaderV2(TinyKtx_ContextHandle handle) {
	TinyKtx_Context *ctx = (TinyKtx_Context *) handle;
	if (ctx == NULL)
		return false;

	ctx->headerPos = ctx->callbacks.tell(ctx->user);
	ctx->callbacks.read(ctx->user, &ctx->headerV2, sizeof(TinyKtx_HeaderV2));

	if (ctx->headerV2.faceCount != 1 && ctx->headerV2.faceCount != 6) {
		ctx->callbacks.error(ctx->user, "no. of Faces must be 1 or 6");
		return false;
	}
	// cap level to max
	if(ctx->headerV2.levelCount >= TINYKTX_MAX_MIPMAPLEVELS) {
		ctx->headerV2.levelCount = TINYKTX_MAX_MIPMAPLEVELS;
	}
	// 0 level count means wants mip maps from the 1 stored
	uint32_t const levelCount = ctx->headerV2.levelCount ? ctx->headerV2.levelCount : 1;

	ctx->callbacks.read(ctx->user, &ctx->levels, sizeof(TinyKtx_HeaderV2) * levelCount);

	if(ctx->headerV2.sgdByteLength > 0) {
		ctx->sgdData = ctx->callbacks.alloc(ctx->user, ctx->headerV2.sgdByteLength);
		ctx->callbacks.seek(ctx->user, ctx->headerV2.sgdByteOffset);
		ctx->callbacks.read(ctx->user, ctx->sgdData, ctx->headerV2.sgdByteLength);
	}

	ctx->v2 = true;
	return true;
}
#endif

bool TinyKtx_ReadHeader(TinyKtx_ContextHandle handle) {

	static uint32_t const sameEndianDecider = 0x04030201;
	static uint32_t const differentEndianDecider = 0x01020304;

	TinyKtx_Context *ctx = (TinyKtx_Context *) handle;
	if (ctx == NULL)
		return false;

	ctx->headerPos = ctx->callbacks.tell(ctx->user);
	ctx->callbacks.read(ctx->user, &ctx->header, sizeof(TinyKtx_Header));

	if (memcmp(&ctx->header.identifier, TinyKtx_fileIdentifier, 12) != 0) {

#ifdef TINY_KTX_EXPERIMENTAL_KTX2_SUPPORT
		if (memcmp(&ctx->header.identifier, TinyKtx_fileIdentifierV2, 12) != 0) {
			ctx->callbacks.error(ctx->user, "Not a KTX V1 or V2 file or corrupted as identified isn't valid");
			return false;
		}
		ctx->callbacks.seek(ctx->user, ctx->headerPos);
		return TinyKtx_ReadHeaderV2(handle);
	}
#else
		ctx->callbacks.error(ctx->user, "Not a KTX file or corrupted as identified isn't valid");
		return false;
	}
#endif

	if (ctx->header.endianness == sameEndianDecider) {
		ctx->sameEndian = true;
	} else if (ctx->header.endianness == differentEndianDecider) {
		ctx->sameEndian = false;
	} else {
		// corrupt or mid endian?
		ctx->callbacks.error(ctx->user, "Endian Error");
		return false;
	}

	if (ctx->header.numberOfFaces != 1 && ctx->header.numberOfFaces != 6) {
		ctx->callbacks.error(ctx->user, "no. of Faces must be 1 or 6");
		return false;
	}

	ctx->keyData = (TinyKtx_KeyValuePair const *) ctx->callbacks.alloc(ctx->user, ctx->header.bytesOfKeyValueData);
	ctx->callbacks.read(ctx->user, (void *) ctx->keyData, ctx->header.bytesOfKeyValueData);

	ctx->firstImagePos = ctx->callbacks.tell(ctx->user);

	ctx->headerValid = true;
	return true;
}

bool TinyKtx_GetValue(TinyKtx_ContextHandle handle, char const *key, void const **value) {
	TinyKtx_Context *ctx = (TinyKtx_Context *) handle;
	if (ctx == NULL)
		return false;
	if (ctx->headerValid == false) {
		ctx->callbacks.error(ctx->user, "Header data hasn't been read yet or its invalid");
		return false;
	}

	if (ctx->keyData == NULL) {
		ctx->callbacks.error(ctx->user, "No key value data in this KTX");
		return false;
	}

	TinyKtx_KeyValuePair const *curKey = ctx->keyData;
	while (((uint8_t *) curKey - (uint8_t *) ctx->keyData) < ctx->header.bytesOfKeyValueData) {
		char const *kvp = (char const *) curKey;

		if (strcmp(kvp, key) == 0) {
			size_t sl = strlen(kvp);
			*value = (void const *) (kvp + sl);
			return true;
		}
		curKey = curKey + ((curKey->size + 3u) & ~3u);
	}
	return false;
}

bool TinyKtx_Is1D(TinyKtx_ContextHandle handle) {
	TinyKtx_Context *ctx = (TinyKtx_Context *) handle;
	if (ctx == NULL)
		return false;
	if (ctx->headerValid == false) {
		ctx->callbacks.error(ctx->user, "Header data hasn't been read yet or its invalid");
		return false;
	}
#ifdef TINY_KTX_EXPERIMENTAL_KTX2_SUPPORT
	if(ctx->v2) {
		return (ctx->header.pixelHeight <= 1) && (ctx->header.pixelDepth <= 1 );
	}
#endif
	return (ctx->header.pixelHeight <= 1) && (ctx->header.pixelDepth <= 1 );
}
bool TinyKtx_Is2D(TinyKtx_ContextHandle handle) {
	TinyKtx_Context *ctx = (TinyKtx_Context *) handle;
	if (ctx == NULL)
		return false;
	if (ctx->headerValid == false) {
		ctx->callbacks.error(ctx->user, "Header data hasn't been read yet or its invalid");
		return false;
	}

#ifdef TINY_KTX_EXPERIMENTAL_KTX2_SUPPORT
	if(ctx->v2) {
		return (ctx->headerV2.pixelHeight > 1 && ctx->headerV2.pixelDepth <= 1);
	}
#endif
	return (ctx->header.pixelHeight > 1 && ctx->header.pixelDepth <= 1);
}
bool TinyKtx_Is3D(TinyKtx_ContextHandle handle) {
	TinyKtx_Context *ctx = (TinyKtx_Context *) handle;
	if (ctx == NULL)
		return false;
	if (ctx->headerValid == false) {
		ctx->callbacks.error(ctx->user, "Header data hasn't been read yet or its invalid");
		return false;
	}

#ifdef TINY_KTX_EXPERIMENTAL_KTX2_SUPPORT
	if(ctx->v2) {
		return (ctx->headerV2.pixelHeight > 1 && ctx->headerV2.pixelDepth > 1);
	}
#endif
	return (ctx->header.pixelHeight > 1 && ctx->header.pixelDepth > 1);
}

bool TinyKtx_IsCubemap(TinyKtx_ContextHandle handle) {
	TinyKtx_Context *ctx = (TinyKtx_Context *) handle;
	if (ctx == NULL)
		return false;
	if (ctx->headerValid == false) {
		ctx->callbacks.error(ctx->user, "Header data hasn't been read yet or its invalid");
		return false;
	}

#ifdef TINY_KTX_EXPERIMENTAL_KTX2_SUPPORT
	if(ctx->v2) {
		return (ctx->headerV2.faceCount == 6);
	}
#endif
	return (ctx->header.numberOfFaces == 6);
}
bool TinyKtx_IsArray(TinyKtx_ContextHandle handle) {
	TinyKtx_Context *ctx = (TinyKtx_Context *) handle;
	if (ctx == NULL)
		return false;
	if (ctx->headerValid == false) {
		ctx->callbacks.error(ctx->user, "Header data hasn't been read yet or its invalid");
		return false;
	}

#ifdef TINY_KTX_EXPERIMENTAL_KTX2_SUPPORT
	if(ctx->v2) {
		return (ctx->headerV2.arrayElementCount > 1);
	}
#endif
	return (ctx->header.numberOfArrayElements > 1);
}

bool TinyKtx_Dimensions(TinyKtx_ContextHandle handle,
												uint32_t *width,
												uint32_t *height,
												uint32_t *depth,
												uint32_t *slices) {
	TinyKtx_Context *ctx = (TinyKtx_Context *) handle;
	if (ctx == NULL)
		return false;
	if (ctx->headerValid == false) {
		ctx->callbacks.error(ctx->user, "Header data hasn't been read yet or its invalid");
		return false;
	}
#ifdef TINY_KTX_EXPERIMENTAL_KTX2_SUPPORT
	if(ctx->v2) {
		if (width)
			*width = ctx->headerV2.pixelWidth;
		if (height)
			*height = ctx->headerV2.pixelWidth;
		if (depth)
			*depth = ctx->headerV2.pixelDepth;
		if (slices)
			*slices = ctx->headerV2.arrayElementCount;
		return true;
	}
#endif
	if (width)
		*width = ctx->header.pixelWidth;
	if (height)
		*height = ctx->header.pixelWidth;
	if (depth)
		*depth = ctx->header.pixelDepth;
	if (slices)
		*slices = ctx->header.numberOfArrayElements;
	return true;
}

uint32_t TinyKtx_Width(TinyKtx_ContextHandle handle) {
	TinyKtx_Context *ctx = (TinyKtx_Context *) handle;
	if (ctx == NULL)
		return 0;
	if (ctx->headerValid == false) {
		ctx->callbacks.error(ctx->user, "Header data hasn't been read yet or its invalid");
		return 0;
	}
#ifdef TINY_KTX_EXPERIMENTAL_KTX2_SUPPORT
	if(ctx->v2) {
		return ctx->headerV2.pixelWidth;
	}
#endif
	return ctx->header.pixelWidth;

}

uint32_t TinyKtx_Height(TinyKtx_ContextHandle handle) {
	TinyKtx_Context *ctx = (TinyKtx_Context *) handle;
	if (ctx == NULL)
		return 0;
	if (ctx->headerValid == false) {
		ctx->callbacks.error(ctx->user, "Header data hasn't been read yet or its invalid");
		return 0;
	}

#ifdef TINY_KTX_EXPERIMENTAL_KTX2_SUPPORT
	if(ctx->v2) {
		return ctx->headerV2.pixelHeight;
	}
#endif
	return ctx->header.pixelHeight;
}

uint32_t TinyKtx_Depth(TinyKtx_ContextHandle handle) {
	TinyKtx_Context *ctx = (TinyKtx_Context *) handle;
	if (ctx == NULL)
		return 0;
	if (ctx->headerValid == false) {
		ctx->callbacks.error(ctx->user, "Header data hasn't been read yet or its invalid");
		return 0;
	}
#ifdef TINY_KTX_EXPERIMENTAL_KTX2_SUPPORT
	if(ctx->v2) {
		return ctx->headerV2.pixelDepth;
	}
#endif
	return ctx->header.pixelDepth;
}

uint32_t TinyKtx_ArraySlices(TinyKtx_ContextHandle handle) {
	TinyKtx_Context *ctx = (TinyKtx_Context *) handle;
	if (ctx == NULL)
		return 0;
	if (ctx->headerValid == false) {
		ctx->callbacks.error(ctx->user, "Header data hasn't been read yet or its invalid");
		return 0;
	}

#ifdef TINY_KTX_EXPERIMENTAL_KTX2_SUPPORT
	if(ctx->v2) {
		return ctx->headerV2.arrayElementCount;
	}
#endif
	return ctx->header.numberOfArrayElements;
}

uint32_t TinyKtx_NumberOfMipmaps(TinyKtx_ContextHandle handle) {
	TinyKtx_Context *ctx = (TinyKtx_Context *) handle;
	if (ctx == NULL)
		return 0;
	if (ctx->headerValid == false) {
		ctx->callbacks.error(ctx->user, "Header data hasn't been read yet or its invalid");
		return 0;
	}
#ifdef TINY_KTX_EXPERIMENTAL_KTX2_SUPPORT
	if(ctx->v2) {
		return ctx->headerV2.levelCount ? ctx->headerV2.levelCount : 1;
	}
#endif

	return ctx->header.numberOfMipmapLevels ? ctx->header.numberOfMipmapLevels : 1;
}

bool TinyKtx_NeedsGenerationOfMipmaps(TinyKtx_ContextHandle handle) {
	TinyKtx_Context *ctx = (TinyKtx_Context *) handle;
	if (ctx == NULL)
		return false;
	if (ctx->headerValid == false) {
		ctx->callbacks.error(ctx->user, "Header data hasn't been read yet or its invalid");
		return false;
	}

#ifdef TINY_KTX_EXPERIMENTAL_KTX2_SUPPORT
	if(ctx->v2) {
		return ctx->headerV2.levelCount == 0;
	}
#endif
	return ctx->header.numberOfMipmapLevels == 0;
}

bool TinyKtx_NeedsEndianCorrecting(TinyKtx_ContextHandle handle) {
	TinyKtx_Context *ctx = (TinyKtx_Context *) handle;
	if (ctx == NULL)
		return false;
	if (ctx->headerValid == false) {
		ctx->callbacks.error(ctx->user, "Header data hasn't been read yet or its invalid");
		return false;
	}

#ifdef TINY_KTX_EXPERIMENTAL_KTX2_SUPPORT
	if(ctx->v2) {
		// TODO should return true if this file is compiled on big endian machines
		return false;
	}
#endif
	return ctx->sameEndian == false;
}

bool TinyKtx_GetFormatGL(TinyKtx_ContextHandle handle, uint32_t *glformat, uint32_t *gltype, uint32_t *glinternalformat, uint32_t* typesize, uint32_t* glbaseinternalformat) {
	TinyKtx_Context *ctx = (TinyKtx_Context *) handle;
	if (ctx == NULL)
		return false;
	if (ctx->headerValid == false) {
		ctx->callbacks.error(ctx->user, "Header data hasn't been read yet or its invalid");
		return false;
	}
#ifdef TINY_KTX_EXPERIMENTAL_KTX2_SUPPORT
	if(ctx->v2) {
		// TODO GL decoder from vkformat and/or DFD
		return false;
	}
#endif

	*glformat = ctx->header.glFormat;
	*gltype = ctx->header.glType;
	*glinternalformat = ctx->header.glInternalFormat;
	*glbaseinternalformat = ctx->header.glBaseInternalFormat;
	*typesize = ctx->header.glBaseInternalFormat;

	return true;
}

#ifdef TINY_KTX_EXPERIMENTAL_KTX2_SUPPORT
static uint32_t TinyKtx_imageSizeV2(TinyKtx_ContextHandle handle, uint32_t mipmaplevel) {
	TinyKtx_Context *ctx = (TinyKtx_Context *) handle;

	if (mipmaplevel >= ctx->headerV2.levelCount) {
		ctx->callbacks.error(ctx->user, "Invalid mipmap level");
		return 0;
	}
	if (mipmaplevel >= TINYKTX_MAX_MIPMAPLEVELS) {
		ctx->callbacks.error(ctx->user, "Invalid mipmap level");
		return 0;
	}

	return ctx->levels[mipmaplevel].uncompressedByteLength;
}
#endif

static uint32_t TinyKtx_imageSize(TinyKtx_ContextHandle handle, uint32_t mipmaplevel, bool seekLast) {
	TinyKtx_Context *ctx = (TinyKtx_Context *) handle;

	if (mipmaplevel >= ctx->header.numberOfMipmapLevels) {
		ctx->callbacks.error(ctx->user, "Invalid mipmap level");
		return 0;
	}
	if (mipmaplevel >= TINYKTX_MAX_MIPMAPLEVELS) {
		ctx->callbacks.error(ctx->user, "Invalid mipmap level");
		return 0;
	}
	if (!seekLast && ctx->mipMapSizes[mipmaplevel] != 0)
		return ctx->mipMapSizes[mipmaplevel];

	uint64_t currentOffset = ctx->firstImagePos;
	for (uint32_t i = 0; i <= mipmaplevel; ++i) {
		uint32_t size;
		// if we have already read this mipmaps size use it
		if (ctx->mipMapSizes[i] != 0) {
			size = ctx->mipMapSizes[i];
			if (seekLast && i == mipmaplevel) {
				ctx->callbacks.seek(ctx->user, currentOffset + sizeof(uint32_t));
			}
		} else {
			// otherwise seek and read it
			ctx->callbacks.seek(ctx->user, currentOffset);
			size_t readchk = ctx->callbacks.read(ctx->user, &size, sizeof(uint32_t));
			if(readchk != 4) {
				ctx->callbacks.error(ctx->user, "Reading image size error");
				return 0;
			}
			// so in the really small print KTX v1 states GL_UNPACK_ALIGNMENT = 4
			// which PVR Texture Tool and I missed. It means pad to 1, 2, 4, 8
			// note 3 or 6 bytes are rounded up.
			// we rely on the loader setting this right, we should handle file with
			// it not to standard but its really the level up that has to do this

			if (ctx->header.numberOfFaces == 6 && ctx->header.numberOfArrayElements == 0) {
				size = ((size + 3u) & ~3u) * 6; // face padding and 6 faces
			}

			ctx->mipMapSizes[i] = size;
		}
		currentOffset += (size + sizeof(uint32_t) + 3u) & ~3u; // size + mip padding
	}

	return ctx->mipMapSizes[mipmaplevel];
}

uint32_t TinyKtx_ImageSize(TinyKtx_ContextHandle handle, uint32_t mipmaplevel) {
	TinyKtx_Context *ctx = (TinyKtx_Context *) handle;
	if (ctx == NULL) return 0;

	if (ctx->headerValid == false) {
		ctx->callbacks.error(ctx->user, "Header data hasn't been read yet or its invalid");
		return 0;
	}
#ifdef TINY_KTX_EXPERIMENTAL_KTX2_SUPPORT
	if(ctx->v2) {
		return TinyKtx_imageSizeV2(handle, mipmaplevel);
	}
#endif
	return TinyKtx_imageSize(handle, mipmaplevel, false);
}

#ifdef TINY_KTX_EXPERIMENTAL_KTX2_SUPPORT
void const *TinyKtx_ImageRawDataV2(TinyKtx_ContextHandle handle, uint32_t mipmaplevel) {
	TinyKtx_Context *ctx = (TinyKtx_Context *) handle;
	if (ctx == NULL)
		return NULL;

	if (ctx->headerValid == false) {
		ctx->callbacks.error(ctx->user, "Header data hasn't been read yet or its invalid");
		return NULL;
	}

	if (mipmaplevel >= ctx->headerV2.levelCount) {
		ctx->callbacks.error(ctx->user, "Invalid mipmap level");
		return NULL;
	}

	if (mipmaplevel >= TINYKTX_MAX_MIPMAPLEVELS) {
		ctx->callbacks.error(ctx->user, "Invalid mipmap level");
		return NULL;
	}

	if (ctx->mipmaps[mipmaplevel] != NULL)
		return ctx->mipmaps[mipmaplevel];

	TinyKtx_LevelV2* lvl = &ctx->levels[mipmaplevel];
	if (lvl->byteLength == 0 || lvl->uncompressedByteLength == 0)
		return NULL;

	// allocate decompressed buffer
	ctx->mipmaps[mipmaplevel] = (uint8_t const*) ctx->callbacks.alloc(ctx->user, lvl->uncompressedByteLength);
	if (ctx->mipmaps[mipmaplevel] == NULL)
		return NULL;

	// handle no super compression first (save an buffer allocation)
	if(ctx->headerV2.supercompressionScheme == TKTX_SUPERCOMPRESSION_NONE) {
		if(lvl->uncompressedByteLength != lvl->byteLength) {
			ctx->callbacks.error(ctx->user, "mipmap image data has no super compression but compressed and uncompressed data sizes are different");
			ctx->callbacks.free(ctx->user, (void*)ctx->mipmaps[mipmaplevel]);
			return NULL;
		}
		ctx->callbacks.seek(ctx->user, lvl->byteOffset);
		ctx->callbacks.read(ctx->user, (void *) ctx->mipmaps[mipmaplevel], lvl->byteLength);
		return ctx->mipmaps[mipmaplevel];
	}

	// this data is super compressed, we need to see if the user provided a decompressor and if so use it

	TinyKtx_SuperDecompress decompressor = NULL;
	// see if the user provided the decompressor we need
	for(size_t i = 0; i < ctx->callbacks.numSuperDecompressors;++i) {
		if(ctx->callbacks.superDecompressors[i].superId == ctx->headerV2.supercompressionScheme) {
			decompressor = ctx->callbacks.superDecompressors[i].decompressor;
		}
	}
	if(decompressor == NULL) {
		ctx->callbacks.error(ctx->user, "user did not provide a decompressor for use with this type of super decompressor");
		ctx->callbacks.free(ctx->user, (void*)ctx->mipmaps[mipmaplevel]);
		return NULL;
	}

	// read the compressed data into its own buffer (free once decompression has occured)
	uint8_t const* compressedBuffer = (uint8_t const*)ctx->callbacks.alloc(ctx->user, lvl->byteLength);
	if(compressedBuffer == NULL) {
		ctx->callbacks.free(ctx->user, (void*)ctx->mipmaps[mipmaplevel]);
		return NULL;
	}
	ctx->callbacks.seek(ctx->user, lvl->byteOffset);
	ctx->callbacks.read(ctx->user, (void *) compressedBuffer, lvl->byteLength);
	bool okay = decompressor(ctx->user, ctx->sgdData, compressedBuffer, lvl->byteLength, ctx->mipmaps[mipmaplevel], lvl->uncompressedByteLength);

	if(!okay) {
		ctx->callbacks.error(ctx->user, "user decompressor failed");
		ctx->callbacks.free(ctx->user, (void *) compressedBuffer);
		ctx->callbacks.free(ctx->user, (void *) ctx->mipmaps[mipmaplevel]);
		return NULL;
	}

	ctx->callbacks.free(ctx->user, (void *) compressedBuffer);
	return ctx->mipmaps[mipmaplevel];

}
#endif

void const *TinyKtx_ImageRawData(TinyKtx_ContextHandle handle, uint32_t mipmaplevel) {
	TinyKtx_Context *ctx = (TinyKtx_Context *) handle;
	if (ctx == NULL)
		return NULL;

	if (ctx->headerValid == false) {
		ctx->callbacks.error(ctx->user, "Header data hasn't been read yet or its invalid");
		return NULL;
	}
#ifdef TINY_KTX_EXPERIMENTAL_KTX2_SUPPORT
	if(ctx->v2) {
		return TinyKtx_ImageRawDataV2(handle, mipmaplevel);
	}
#endif

	if (mipmaplevel >= ctx->header.numberOfMipmapLevels) {
		ctx->callbacks.error(ctx->user, "Invalid mipmap level");
		return NULL;
	}

	if (mipmaplevel >= TINYKTX_MAX_MIPMAPLEVELS) {
		ctx->callbacks.error(ctx->user, "Invalid mipmap level");
		return NULL;
	}

	if (ctx->mipmaps[mipmaplevel] != NULL)
		return ctx->mipmaps[mipmaplevel];

	uint32_t size = TinyKtx_imageSize(handle, mipmaplevel, true);
	if (size == 0)
		return NULL;

	ctx->mipmaps[mipmaplevel] = (uint8_t const*) ctx->callbacks.alloc(ctx->user, size);
	if (ctx->mipmaps[mipmaplevel]) {
		ctx->callbacks.read(ctx->user, (void *) ctx->mipmaps[mipmaplevel], size);
	}

	return ctx->mipmaps[mipmaplevel];
}

#define FT(fmt, type, intfmt, size) *glformat = TINYKTX_GL_FORMAT_##fmt; \
                                    *gltype = TINYKTX_GL_TYPE_##type; \
                                    *glinternalformat = TINYKTX_GL_INTFORMAT_##intfmt; \
                                    *typesize = size; \
                                    return true;
#define FTC(fmt, intfmt) *glformat = TINYKTX_GL_FORMAT_##fmt; \
                                    *gltype = TINYKTX_GL_TYPE_COMPRESSED; \
                                    *glinternalformat = TINYKTX_GL_COMPRESSED_##intfmt; \
                                    *typesize = 1; \
                                    return true;

bool TinyKtx_CrackFormatToGL(TinyKtx_Format format,
														 uint32_t *glformat,
														 uint32_t *gltype,
														 uint32_t *glinternalformat,
														 uint32_t *typesize) {
	switch (format) {
	case TKTX_R4G4_UNORM_PACK8: break;
	case TKTX_R4G4B4A4_UNORM_PACK16: FT(RGBA, UNSIGNED_SHORT_4_4_4_4, RGBA4, 2)
	case TKTX_B4G4R4A4_UNORM_PACK16: FT(BGRA, UNSIGNED_SHORT_4_4_4_4_REV, RGBA4, 2)
	case TKTX_R5G6B5_UNORM_PACK16: FT(RGB, UNSIGNED_SHORT_5_6_5, RGB565, 2)
	case TKTX_B5G6R5_UNORM_PACK16: FT(BGR, UNSIGNED_SHORT_5_6_5_REV, RGB565, 2)
	case TKTX_R5G5B5A1_UNORM_PACK16: FT(RGBA, UNSIGNED_SHORT_5_5_5_1, RGB5_A1, 2)
	case TKTX_A1R5G5B5_UNORM_PACK16: FT(RGBA, UNSIGNED_SHORT_1_5_5_5_REV, RGB5_A1, 2)
	case TKTX_B5G5R5A1_UNORM_PACK16: FT(BGRA, UNSIGNED_SHORT_5_5_5_1, RGB5_A1, 2)

	case TKTX_A2R10G10B10_UNORM_PACK32: FT(BGRA, UNSIGNED_INT_2_10_10_10_REV, RGB10_A2, 4)
	case TKTX_A2R10G10B10_UINT_PACK32: FT(BGRA_INTEGER, UNSIGNED_INT_2_10_10_10_REV, RGB10_A2, 4)
	case TKTX_A2B10G10R10_UNORM_PACK32: FT(RGBA, UNSIGNED_INT_2_10_10_10_REV, RGB10_A2, 4)
	case TKTX_A2B10G10R10_UINT_PACK32: FT(RGBA_INTEGER, UNSIGNED_INT_2_10_10_10_REV, RGB10_A2, 4)

	case TKTX_R8_UNORM: FT(RED, UNSIGNED_BYTE, R8, 1)
	case TKTX_R8_SNORM: FT(RED, BYTE, R8_SNORM, 1)
	case TKTX_R8_UINT: FT(RED_INTEGER, UNSIGNED_BYTE, R8UI, 1)
	case TKTX_R8_SINT: FT(RED_INTEGER, BYTE, R8I, 1)
	case TKTX_R8_SRGB: FT(SLUMINANCE, UNSIGNED_BYTE, SRGB8, 1)

	case TKTX_R8G8_UNORM: FT(RG, UNSIGNED_BYTE, RG8, 1)
	case TKTX_R8G8_SNORM: FT(RG, BYTE, RG8_SNORM, 1)
	case TKTX_R8G8_UINT: FT(RG_INTEGER, UNSIGNED_BYTE, RG8UI, 1)
	case TKTX_R8G8_SINT: FT(RG_INTEGER, BYTE, RG8I, 1)
	case TKTX_R8G8_SRGB: FT(SLUMINANCE_ALPHA, UNSIGNED_BYTE, SRGB8, 1)

	case TKTX_R8G8B8_UNORM: FT(RGB, UNSIGNED_BYTE, RGB8, 1)
	case TKTX_R8G8B8_SNORM: FT(RGB, BYTE, RGB8_SNORM, 1)
	case TKTX_R8G8B8_UINT: FT(RGB_INTEGER, UNSIGNED_BYTE, RGB8UI, 1)
	case TKTX_R8G8B8_SINT: FT(RGB_INTEGER, BYTE, RGB8I, 1)
	case TKTX_R8G8B8_SRGB: FT(SRGB, UNSIGNED_BYTE, SRGB8, 1)

	case TKTX_B8G8R8_UNORM: FT(BGR, UNSIGNED_BYTE, RGB8, 1)
	case TKTX_B8G8R8_SNORM: FT(BGR, BYTE, RGB8_SNORM, 1)
	case TKTX_B8G8R8_UINT: FT(BGR_INTEGER, UNSIGNED_BYTE, RGB8UI, 1)
	case TKTX_B8G8R8_SINT: FT(BGR_INTEGER, BYTE, RGB8I, 1)
	case TKTX_B8G8R8_SRGB: FT(BGR, UNSIGNED_BYTE, SRGB8, 1)

	case TKTX_R8G8B8A8_UNORM:FT(RGBA, UNSIGNED_BYTE, RGBA8, 1)
	case TKTX_R8G8B8A8_SNORM:FT(RGBA, BYTE, RGBA8_SNORM, 1)
	case TKTX_R8G8B8A8_UINT: FT(RGBA_INTEGER, UNSIGNED_BYTE, RGBA8UI, 1)
	case TKTX_R8G8B8A8_SINT: FT(RGBA_INTEGER, BYTE, RGBA8I, 1)
	case TKTX_R8G8B8A8_SRGB: FT(SRGB_ALPHA, UNSIGNED_BYTE, SRGB8, 1)

	case TKTX_B8G8R8A8_UNORM: FT(BGRA, UNSIGNED_BYTE, RGBA8, 1)
	case TKTX_B8G8R8A8_SNORM: FT(BGRA, BYTE, RGBA8_SNORM, 1)
	case TKTX_B8G8R8A8_UINT: FT(BGRA_INTEGER, UNSIGNED_BYTE, RGBA8UI, 1)
	case TKTX_B8G8R8A8_SINT: FT(BGRA_INTEGER, BYTE, RGBA8I, 1)
	case TKTX_B8G8R8A8_SRGB: FT(BGRA, UNSIGNED_BYTE, SRGB8, 1)

	case TKTX_E5B9G9R9_UFLOAT_PACK32: FT(BGR, UNSIGNED_INT_5_9_9_9_REV, RGB9_E5, 4);
	case TKTX_A8B8G8R8_UNORM_PACK32: FT(ABGR, UNSIGNED_BYTE, RGBA8, 1)
	case TKTX_A8B8G8R8_SNORM_PACK32: FT(ABGR, BYTE, RGBA8, 1)
	case TKTX_A8B8G8R8_UINT_PACK32: FT(ABGR, UNSIGNED_BYTE, RGBA8UI, 1)
	case TKTX_A8B8G8R8_SINT_PACK32: FT(ABGR, BYTE, RGBA8I, 1)
	case TKTX_A8B8G8R8_SRGB_PACK32: FT(ABGR, UNSIGNED_BYTE, SRGB8, 1)
	case TKTX_B10G11R11_UFLOAT_PACK32: FT(BGR, UNSIGNED_INT_10F_11F_11F_REV, R11F_G11F_B10F, 4)

	case TKTX_R16_UNORM: FT(RED, UNSIGNED_SHORT, R16, 2)
	case TKTX_R16_SNORM: FT(RED, SHORT, R16_SNORM, 2)
	case TKTX_R16_UINT: FT(RED_INTEGER, UNSIGNED_SHORT, R16UI, 2)
	case TKTX_R16_SINT: FT(RED_INTEGER, SHORT, R16I, 2)
	case TKTX_R16_SFLOAT:FT(RED, HALF_FLOAT, R16F, 2)

	case TKTX_R16G16_UNORM: FT(RG, UNSIGNED_SHORT, RG16, 2)
	case TKTX_R16G16_SNORM: FT(RG, SHORT, RG16_SNORM, 2)
	case TKTX_R16G16_UINT: FT(RG_INTEGER, UNSIGNED_SHORT, RG16UI, 2)
	case TKTX_R16G16_SINT: FT(RG_INTEGER, SHORT, RG16I, 2)
	case TKTX_R16G16_SFLOAT:FT(RG, HALF_FLOAT, RG16F, 2)

	case TKTX_R16G16B16_UNORM: FT(RGB, UNSIGNED_SHORT, RGB16, 2)
	case TKTX_R16G16B16_SNORM: FT(RGB, SHORT, RGB16_SNORM, 2)
	case TKTX_R16G16B16_UINT: FT(RGB_INTEGER, UNSIGNED_SHORT, RGB16UI, 2)
	case TKTX_R16G16B16_SINT: FT(RGB_INTEGER, SHORT, RGB16I, 2)
	case TKTX_R16G16B16_SFLOAT: FT(RGB, HALF_FLOAT, RGB16F, 2)

	case TKTX_R16G16B16A16_UNORM: FT(RGBA, UNSIGNED_SHORT, RGBA16, 2)
	case TKTX_R16G16B16A16_SNORM: FT(RGBA, SHORT, RGBA16_SNORM, 2)
	case TKTX_R16G16B16A16_UINT: FT(RGBA_INTEGER, UNSIGNED_SHORT, RGBA16UI, 2)
	case TKTX_R16G16B16A16_SINT: FT(RGBA_INTEGER, SHORT, RGBA16I, 2)
	case TKTX_R16G16B16A16_SFLOAT:FT(RGBA, HALF_FLOAT, RGBA16F, 2)

	case TKTX_R32_UINT: FT(RED_INTEGER, UNSIGNED_INT, R32UI, 4)
	case TKTX_R32_SINT: FT(RED_INTEGER, INT, R32I, 4)
	case TKTX_R32_SFLOAT: FT(RED, FLOAT, R32F, 4)

	case TKTX_R32G32_UINT: FT(RG_INTEGER, UNSIGNED_INT, RG32UI, 4)
	case TKTX_R32G32_SINT: FT(RG_INTEGER, INT, RG32I, 4)
	case TKTX_R32G32_SFLOAT: FT(RG, FLOAT, RG32F, 4)

	case TKTX_R32G32B32_UINT: FT(RGB_INTEGER, UNSIGNED_INT, RGB32UI, 4)
	case TKTX_R32G32B32_SINT: FT(RGB_INTEGER, INT, RGB32I, 4)
	case TKTX_R32G32B32_SFLOAT: FT(RGB_INTEGER, FLOAT, RGB32F, 4)

	case TKTX_R32G32B32A32_UINT: FT(RGBA_INTEGER, UNSIGNED_INT, RGBA32UI, 4)
	case TKTX_R32G32B32A32_SINT: FT(RGBA_INTEGER, INT, RGBA32I, 4)
	case TKTX_R32G32B32A32_SFLOAT:FT(RGBA, FLOAT, RGBA32F, 4)

	case TKTX_BC1_RGB_UNORM_BLOCK: FTC(RGB, RGB_S3TC_DXT1)
	case TKTX_BC1_RGB_SRGB_BLOCK: FTC(RGB, SRGB_S3TC_DXT1)
	case TKTX_BC1_RGBA_UNORM_BLOCK: FTC(RGBA, RGBA_S3TC_DXT1)
	case TKTX_BC1_RGBA_SRGB_BLOCK: FTC(RGBA, SRGB_ALPHA_S3TC_DXT1)
	case TKTX_BC2_UNORM_BLOCK: FTC(RGBA, RGBA_S3TC_DXT3)
	case TKTX_BC2_SRGB_BLOCK: FTC(RGBA, SRGB_ALPHA_S3TC_DXT3)
	case TKTX_BC3_UNORM_BLOCK: FTC(RGBA, RGBA_S3TC_DXT5)
	case TKTX_BC3_SRGB_BLOCK: FTC(RGBA, SRGB_ALPHA_S3TC_DXT5)
	case TKTX_BC4_UNORM_BLOCK: FTC(RED, RED_RGTC1)
	case TKTX_BC4_SNORM_BLOCK: FTC(RED, SIGNED_RED_RGTC1)
	case TKTX_BC5_UNORM_BLOCK: FTC(RG, RED_GREEN_RGTC2)
	case TKTX_BC5_SNORM_BLOCK: FTC(RG, SIGNED_RED_GREEN_RGTC2)
	case TKTX_BC6H_UFLOAT_BLOCK: FTC(RGB, RGB_BPTC_UNSIGNED_FLOAT)
	case TKTX_BC6H_SFLOAT_BLOCK: FTC(RGB, RGB_BPTC_SIGNED_FLOAT)
	case TKTX_BC7_UNORM_BLOCK: FTC(RGBA, RGBA_BPTC_UNORM)
	case TKTX_BC7_SRGB_BLOCK: FTC(RGBA, SRGB_ALPHA_BPTC_UNORM)

	case TKTX_ETC2_R8G8B8_UNORM_BLOCK: FTC(RGB, RGB8_ETC2)
	case TKTX_ETC2_R8G8B8A1_UNORM_BLOCK: FTC(RGBA, RGB8_PUNCHTHROUGH_ALPHA1_ETC2)
	case TKTX_ETC2_R8G8B8A8_UNORM_BLOCK: FTC(RGBA, RGBA8_ETC2_EAC)
	case TKTX_ETC2_R8G8B8_SRGB_BLOCK: FTC(SRGB, SRGB8_ETC2)
	case TKTX_ETC2_R8G8B8A1_SRGB_BLOCK: FTC(SRGB_ALPHA, SRGB8_PUNCHTHROUGH_ALPHA1_ETC2)
	case TKTX_ETC2_R8G8B8A8_SRGB_BLOCK: FTC(SRGB_ALPHA, SRGB8_ALPHA8_ETC2_EAC)
	case TKTX_EAC_R11_UNORM_BLOCK: FTC(RED, R11_EAC)
	case TKTX_EAC_R11G11_UNORM_BLOCK: FTC(RG, RG11_EAC)
	case TKTX_EAC_R11_SNORM_BLOCK: FTC(RED, SIGNED_R11_EAC)
	case TKTX_EAC_R11G11_SNORM_BLOCK: FTC(RG, SIGNED_RG11_EAC)

	case TKTX_PVR_2BPP_BLOCK: FTC(RGB, RGB_PVRTC_2BPPV1)
	case TKTX_PVR_2BPPA_BLOCK: FTC(RGBA, RGBA_PVRTC_2BPPV1);
	case TKTX_PVR_4BPP_BLOCK: FTC(RGB, RGB_PVRTC_4BPPV1)
	case TKTX_PVR_4BPPA_BLOCK: FTC(RGB, RGB_PVRTC_4BPPV1)
	case TKTX_PVR_2BPP_SRGB_BLOCK: FTC(SRGB, SRGB_PVRTC_2BPPV1)
	case TKTX_PVR_2BPPA_SRGB_BLOCK: FTC(SRGB_ALPHA, SRGB_ALPHA_PVRTC_2BPPV1);
	case TKTX_PVR_4BPP_SRGB_BLOCK: FTC(SRGB, SRGB_PVRTC_2BPPV1)
	case TKTX_PVR_4BPPA_SRGB_BLOCK: FTC(SRGB_ALPHA, SRGB_ALPHA_PVRTC_2BPPV1);

	case TKTX_ASTC_4x4_UNORM_BLOCK: FTC(RGBA, RGBA_ASTC_4x4)
	case TKTX_ASTC_4x4_SRGB_BLOCK: FTC(SRGB_ALPHA, SRGB8_ALPHA8_ASTC_4x4)
	case TKTX_ASTC_5x4_UNORM_BLOCK: FTC(RGBA, RGBA_ASTC_5x4)
	case TKTX_ASTC_5x4_SRGB_BLOCK: FTC(SRGB_ALPHA, SRGB8_ALPHA8_ASTC_5x4)
	case TKTX_ASTC_5x5_UNORM_BLOCK: FTC(RGBA, RGBA_ASTC_5x5)
	case TKTX_ASTC_5x5_SRGB_BLOCK: FTC(SRGB_ALPHA, SRGB8_ALPHA8_ASTC_5x5)
	case TKTX_ASTC_6x5_UNORM_BLOCK: FTC(RGBA, RGBA_ASTC_6x5)
	case TKTX_ASTC_6x5_SRGB_BLOCK: FTC(SRGB_ALPHA, SRGB8_ALPHA8_ASTC_6x5)
	case TKTX_ASTC_6x6_UNORM_BLOCK: FTC(RGBA, RGBA_ASTC_6x6)
	case TKTX_ASTC_6x6_SRGB_BLOCK: FTC(SRGB_ALPHA, SRGB8_ALPHA8_ASTC_6x6)
	case TKTX_ASTC_8x5_UNORM_BLOCK: FTC(RGBA, RGBA_ASTC_8x5)
	case TKTX_ASTC_8x5_SRGB_BLOCK: FTC(SRGB_ALPHA, SRGB8_ALPHA8_ASTC_8x5)
	case TKTX_ASTC_8x6_UNORM_BLOCK: FTC(RGBA, RGBA_ASTC_8x6)
	case TKTX_ASTC_8x6_SRGB_BLOCK: FTC(SRGB_ALPHA, SRGB8_ALPHA8_ASTC_8x6)
	case TKTX_ASTC_8x8_UNORM_BLOCK: FTC(RGBA, RGBA_ASTC_8x8)
	case TKTX_ASTC_8x8_SRGB_BLOCK: FTC(SRGB_ALPHA, SRGB8_ALPHA8_ASTC_8x8)
	case TKTX_ASTC_10x5_UNORM_BLOCK: FTC(RGBA, RGBA_ASTC_10x5)
	case TKTX_ASTC_10x5_SRGB_BLOCK: FTC(SRGB_ALPHA, SRGB8_ALPHA8_ASTC_10x5)
	case TKTX_ASTC_10x6_UNORM_BLOCK: FTC(RGBA, RGBA_ASTC_10x6)
	case TKTX_ASTC_10x6_SRGB_BLOCK: FTC(SRGB_ALPHA, SRGB8_ALPHA8_ASTC_10x6)
	case TKTX_ASTC_10x8_UNORM_BLOCK: FTC(RGBA, RGBA_ASTC_10x8);
	case TKTX_ASTC_10x8_SRGB_BLOCK: FTC(SRGB_ALPHA, SRGB8_ALPHA8_ASTC_10x8)
	case TKTX_ASTC_10x10_UNORM_BLOCK: FTC(RGBA, RGBA_ASTC_10x10)
	case TKTX_ASTC_10x10_SRGB_BLOCK: FTC(SRGB_ALPHA, SRGB8_ALPHA8_ASTC_10x10)
	case TKTX_ASTC_12x10_UNORM_BLOCK: FTC(RGBA, RGBA_ASTC_12x10)
	case TKTX_ASTC_12x10_SRGB_BLOCK: FTC(SRGB_ALPHA, SRGB8_ALPHA8_ASTC_12x10)
	case TKTX_ASTC_12x12_UNORM_BLOCK: FTC(RGBA, RGBA_ASTC_12x12)
	case TKTX_ASTC_12x12_SRGB_BLOCK: FTC(SRGB_ALPHA, SRGB8_ALPHA8_ASTC_12x12)

	default:break;
	}
	return false;
}
#undef FT
#undef FTC

TinyKtx_Format TinyKtx_CrackFormatFromGL(uint32_t const glformat,
																				 uint32_t const gltype,
																				 uint32_t const glinternalformat,
																				 uint32_t const typesize) {
	switch (glinternalformat) {
	case TINYKTX_GL_COMPRESSED_RGB_S3TC_DXT1: return TKTX_BC1_RGB_UNORM_BLOCK;
	case TINYKTX_GL_COMPRESSED_RGBA_S3TC_DXT1: return TKTX_BC1_RGBA_UNORM_BLOCK;
	case TINYKTX_GL_COMPRESSED_RGBA_S3TC_DXT3: return TKTX_BC2_UNORM_BLOCK;
	case TINYKTX_GL_COMPRESSED_RGBA_S3TC_DXT5: return TKTX_BC3_UNORM_BLOCK;
	case TINYKTX_GL_COMPRESSED_3DC_X_AMD: return TKTX_BC4_UNORM_BLOCK;
	case TINYKTX_GL_COMPRESSED_3DC_XY_AMD: return TKTX_BC5_UNORM_BLOCK;
	case TINYKTX_GL_COMPRESSED_SRGB_PVRTC_2BPPV1: return TKTX_PVR_2BPP_SRGB_BLOCK;
	case TINYKTX_GL_COMPRESSED_SRGB_PVRTC_4BPPV1: return TKTX_PVR_2BPPA_SRGB_BLOCK;
	case TINYKTX_GL_COMPRESSED_SRGB_ALPHA_PVRTC_2BPPV1: return TKTX_PVR_2BPPA_SRGB_BLOCK;
	case TINYKTX_GL_COMPRESSED_SRGB_ALPHA_PVRTC_4BPPV1: return TKTX_PVR_4BPPA_SRGB_BLOCK;
	case TINYKTX_GL_COMPRESSED_RGB_PVRTC_4BPPV1: return TKTX_PVR_4BPP_BLOCK;
	case TINYKTX_GL_COMPRESSED_RGB_PVRTC_2BPPV1: return TKTX_PVR_2BPP_BLOCK;
	case TINYKTX_GL_COMPRESSED_RGBA_PVRTC_4BPPV1: return TKTX_PVR_4BPPA_BLOCK;
	case TINYKTX_GL_COMPRESSED_RGBA_PVRTC_2BPPV1: return TKTX_PVR_2BPPA_BLOCK;
	case TINYKTX_GL_COMPRESSED_SRGB_S3TC_DXT1: return TKTX_BC1_RGB_SRGB_BLOCK;
	case TINYKTX_GL_COMPRESSED_SRGB_ALPHA_S3TC_DXT1: return TKTX_BC1_RGBA_SRGB_BLOCK;
	case TINYKTX_GL_COMPRESSED_SRGB_ALPHA_S3TC_DXT3: return TKTX_BC2_SRGB_BLOCK;
	case TINYKTX_GL_COMPRESSED_SRGB_ALPHA_S3TC_DXT5: return TKTX_BC3_SRGB_BLOCK;
	case TINYKTX_GL_COMPRESSED_LUMINANCE_LATC1: return TKTX_BC4_UNORM_BLOCK;
	case TINYKTX_GL_COMPRESSED_SIGNED_LUMINANCE_LATC1: return TKTX_BC4_SNORM_BLOCK;
	case TINYKTX_GL_COMPRESSED_LUMINANCE_ALPHA_LATC2: return TKTX_BC5_UNORM_BLOCK;
	case TINYKTX_GL_COMPRESSED_SIGNED_LUMINANCE_ALPHA_LATC2: return TKTX_BC5_SNORM_BLOCK;
	case TINYKTX_GL_COMPRESSED_RED_RGTC1: return TKTX_BC4_UNORM_BLOCK;
	case TINYKTX_GL_COMPRESSED_SIGNED_RED_RGTC1: return TKTX_BC4_SNORM_BLOCK;
	case TINYKTX_GL_COMPRESSED_RED_GREEN_RGTC2: return TKTX_BC5_UNORM_BLOCK;
	case TINYKTX_GL_COMPRESSED_SIGNED_RED_GREEN_RGTC2: return TKTX_BC5_SNORM_BLOCK;
	case TINYKTX_GL_COMPRESSED_ETC1_RGB8_OES: return TKTX_ETC2_R8G8B8_UNORM_BLOCK;
	case TINYKTX_GL_COMPRESSED_RGBA_BPTC_UNORM: return TKTX_BC7_UNORM_BLOCK;
	case TINYKTX_GL_COMPRESSED_SRGB_ALPHA_BPTC_UNORM: return TKTX_BC7_SRGB_BLOCK;
	case TINYKTX_GL_COMPRESSED_RGB_BPTC_SIGNED_FLOAT: return TKTX_BC6H_SFLOAT_BLOCK;
	case TINYKTX_GL_COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT: return TKTX_BC6H_UFLOAT_BLOCK;
	case TINYKTX_GL_COMPRESSED_R11_EAC: return TKTX_EAC_R11_UNORM_BLOCK;
	case TINYKTX_GL_COMPRESSED_SIGNED_R11_EAC: return TKTX_EAC_R11_SNORM_BLOCK;
	case TINYKTX_GL_COMPRESSED_RG11_EAC: return TKTX_EAC_R11G11_UNORM_BLOCK;
	case TINYKTX_GL_COMPRESSED_SIGNED_RG11_EAC: return TKTX_EAC_R11G11_UNORM_BLOCK;
	case TINYKTX_GL_COMPRESSED_RGB8_ETC2: return TKTX_ETC2_R8G8B8_UNORM_BLOCK;
	case TINYKTX_GL_COMPRESSED_SRGB8_ETC2: return TKTX_ETC2_R8G8B8_SRGB_BLOCK;
	case TINYKTX_GL_COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2: return TKTX_ETC2_R8G8B8A1_UNORM_BLOCK;
	case TINYKTX_GL_COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2: return TKTX_ETC2_R8G8B8A1_SRGB_BLOCK;
	case TINYKTX_GL_COMPRESSED_RGBA8_ETC2_EAC: return TKTX_ETC2_R8G8B8A8_UNORM_BLOCK;
	case TINYKTX_GL_COMPRESSED_SRGB8_ALPHA8_ETC2_EAC: return TKTX_ETC2_R8G8B8A8_SRGB_BLOCK;
	case TINYKTX_GL_COMPRESSED_RGBA_ASTC_4x4: return TKTX_ASTC_4x4_UNORM_BLOCK;
	case TINYKTX_GL_COMPRESSED_RGBA_ASTC_5x4: return TKTX_ASTC_5x4_UNORM_BLOCK;
	case TINYKTX_GL_COMPRESSED_RGBA_ASTC_5x5: return TKTX_ASTC_5x5_UNORM_BLOCK;
	case TINYKTX_GL_COMPRESSED_RGBA_ASTC_6x5: return TKTX_ASTC_6x5_UNORM_BLOCK;
	case TINYKTX_GL_COMPRESSED_RGBA_ASTC_6x6: return TKTX_ASTC_6x6_UNORM_BLOCK;
	case TINYKTX_GL_COMPRESSED_RGBA_ASTC_8x5: return TKTX_ASTC_8x5_UNORM_BLOCK;
	case TINYKTX_GL_COMPRESSED_RGBA_ASTC_8x6: return TKTX_ASTC_8x6_UNORM_BLOCK;
	case TINYKTX_GL_COMPRESSED_RGBA_ASTC_8x8: return TKTX_ASTC_8x8_UNORM_BLOCK;
	case TINYKTX_GL_COMPRESSED_RGBA_ASTC_10x5: return TKTX_ASTC_10x5_UNORM_BLOCK;
	case TINYKTX_GL_COMPRESSED_RGBA_ASTC_10x6: return TKTX_ASTC_10x6_UNORM_BLOCK;
	case TINYKTX_GL_COMPRESSED_RGBA_ASTC_10x8: return TKTX_ASTC_10x8_UNORM_BLOCK;
	case TINYKTX_GL_COMPRESSED_RGBA_ASTC_10x10: return TKTX_ASTC_10x10_UNORM_BLOCK;
	case TINYKTX_GL_COMPRESSED_RGBA_ASTC_12x10: return TKTX_ASTC_12x10_UNORM_BLOCK;
	case TINYKTX_GL_COMPRESSED_RGBA_ASTC_12x12: return TKTX_ASTC_12x12_UNORM_BLOCK;
	case TINYKTX_GL_COMPRESSED_SRGB8_ALPHA8_ASTC_4x4: return TKTX_ASTC_4x4_SRGB_BLOCK;
	case TINYKTX_GL_COMPRESSED_SRGB8_ALPHA8_ASTC_5x4: return TKTX_ASTC_5x4_SRGB_BLOCK;
	case TINYKTX_GL_COMPRESSED_SRGB8_ALPHA8_ASTC_5x5: return TKTX_ASTC_5x5_SRGB_BLOCK;
	case TINYKTX_GL_COMPRESSED_SRGB8_ALPHA8_ASTC_6x5: return TKTX_ASTC_6x5_SRGB_BLOCK;
	case TINYKTX_GL_COMPRESSED_SRGB8_ALPHA8_ASTC_6x6: return TKTX_ASTC_6x6_SRGB_BLOCK;
	case TINYKTX_GL_COMPRESSED_SRGB8_ALPHA8_ASTC_8x5: return TKTX_ASTC_8x5_SRGB_BLOCK;
	case TINYKTX_GL_COMPRESSED_SRGB8_ALPHA8_ASTC_8x6: return TKTX_ASTC_8x6_SRGB_BLOCK;
	case TINYKTX_GL_COMPRESSED_SRGB8_ALPHA8_ASTC_8x8: return TKTX_ASTC_8x8_SRGB_BLOCK;
	case TINYKTX_GL_COMPRESSED_SRGB8_ALPHA8_ASTC_10x5: return TKTX_ASTC_10x5_SRGB_BLOCK;
	case TINYKTX_GL_COMPRESSED_SRGB8_ALPHA8_ASTC_10x6: return TKTX_ASTC_10x6_SRGB_BLOCK;
	case TINYKTX_GL_COMPRESSED_SRGB8_ALPHA8_ASTC_10x8: return TKTX_ASTC_10x8_SRGB_BLOCK;
	case TINYKTX_GL_COMPRESSED_SRGB8_ALPHA8_ASTC_10x10: return TKTX_ASTC_10x10_SRGB_BLOCK;
	case TINYKTX_GL_COMPRESSED_SRGB8_ALPHA8_ASTC_12x10: return TKTX_ASTC_12x10_SRGB_BLOCK;
	case TINYKTX_GL_COMPRESSED_SRGB8_ALPHA8_ASTC_12x12: return TKTX_ASTC_12x12_SRGB_BLOCK;

		// non compressed
	case TINYKTX_GL_INTFORMAT_R8: return TKTX_R8_UNORM;
	case TINYKTX_GL_INTFORMAT_RG8: return TKTX_R8G8_UNORM;
	case TINYKTX_GL_INTFORMAT_RGB8: return TKTX_R8G8B8_UNORM;
	case TINYKTX_GL_INTFORMAT_RGBA8:
		if(glformat == TINYKTX_GL_FORMAT_RGBA) {
			if(gltype == TINYKTX_GL_TYPE_UNSIGNED_BYTE) {
				return TKTX_R8G8B8A8_UNORM;
			} else if(gltype == TINYKTX_GL_TYPE_BYTE) {
				return TKTX_R8G8B8A8_SNORM;
			}
		} else if(glformat == TINYKTX_GL_FORMAT_BGRA) {
			if(gltype == TINYKTX_GL_TYPE_UNSIGNED_BYTE) {
				return TKTX_B8G8R8A8_UNORM;
			} else if(gltype == TINYKTX_GL_TYPE_BYTE) {
				return TKTX_B8G8R8A8_SNORM;
			}
		} else if(glformat == TINYKTX_GL_FORMAT_ABGR) {
			if(gltype == TINYKTX_GL_TYPE_UNSIGNED_BYTE) {
				return TKTX_A8B8G8R8_UNORM_PACK32;
			} else if(gltype == TINYKTX_GL_TYPE_BYTE) {
				return TKTX_A8B8G8R8_SNORM_PACK32;
			}
		}
		break;
	case TINYKTX_GL_INTFORMAT_R8_SNORM: return TKTX_R8_SNORM;
	case TINYKTX_GL_INTFORMAT_RG8_SNORM: return TKTX_R8G8_SNORM;
	case TINYKTX_GL_INTFORMAT_RGB8_SNORM: return TKTX_R8G8B8_SNORM;
	case TINYKTX_GL_INTFORMAT_RGBA8_SNORM: return TKTX_R8G8B8A8_SNORM;

	case TINYKTX_GL_INTFORMAT_R16: return TKTX_R16_UNORM;
	case TINYKTX_GL_INTFORMAT_RG16: return TKTX_R16G16_UNORM;
	case TINYKTX_GL_INTFORMAT_RGB16: return TKTX_R16G16B16_UNORM;
	case TINYKTX_GL_INTFORMAT_RGBA16: return TKTX_R16G16B16A16_UNORM;

	case TINYKTX_GL_INTFORMAT_R16_SNORM:return TKTX_R16_SNORM;
	case TINYKTX_GL_INTFORMAT_RG16_SNORM: return TKTX_R16G16_SNORM;
	case TINYKTX_GL_INTFORMAT_RGB16_SNORM: return TKTX_R16G16B16_SNORM;
	case TINYKTX_GL_INTFORMAT_RGBA16_SNORM: return TKTX_R16G16B16A16_SNORM;

	case TINYKTX_GL_INTFORMAT_R8I: return TKTX_R8_SINT;
	case TINYKTX_GL_INTFORMAT_RG8I: return TKTX_R8G8_SINT;
	case TINYKTX_GL_INTFORMAT_RGB8I:return TKTX_R8G8B8_SINT;
	case TINYKTX_GL_INTFORMAT_RGBA8I:
		if(glformat == TINYKTX_GL_FORMAT_RGBA || glformat == TINYKTX_GL_FORMAT_RGBA_INTEGER) {
			return TKTX_R8G8B8A8_SINT;
		} else if(glformat == TINYKTX_GL_FORMAT_BGRA || glformat == TINYKTX_GL_FORMAT_BGRA_INTEGER) {
			return TKTX_B8G8R8A8_SINT;
		} else if(glformat == TINYKTX_GL_FORMAT_ABGR) {
			return TKTX_A8B8G8R8_SINT_PACK32;
		}
		break;

	case TINYKTX_GL_INTFORMAT_R16I: return TKTX_R16_SINT;
	case TINYKTX_GL_INTFORMAT_RG16I: return TKTX_R16G16_SINT;
	case TINYKTX_GL_INTFORMAT_RGB16I:return TKTX_R16G16B16_SINT;
	case TINYKTX_GL_INTFORMAT_RGBA16I:return TKTX_R16G16B16A16_SINT;

	case TINYKTX_GL_INTFORMAT_R32I: return TKTX_R32_SINT;
	case TINYKTX_GL_INTFORMAT_RG32I: return TKTX_R32G32_SINT;
	case TINYKTX_GL_INTFORMAT_RGB32I: return TKTX_R32G32B32_SINT;
	case TINYKTX_GL_INTFORMAT_RGBA32I:return TKTX_R32G32B32A32_SINT;

	case TINYKTX_GL_INTFORMAT_R8UI: return TKTX_R8_UINT;
	case TINYKTX_GL_INTFORMAT_RG8UI: return TKTX_R8G8_UINT;
	case TINYKTX_GL_INTFORMAT_RGB8UI: return TKTX_R8G8B8_UINT;
	case TINYKTX_GL_INTFORMAT_RGBA8UI:
		if(glformat == TINYKTX_GL_FORMAT_RGBA || glformat == TINYKTX_GL_FORMAT_RGBA_INTEGER) {
			return TKTX_R8G8B8A8_UINT;
		} else if(glformat == TINYKTX_GL_FORMAT_BGRA || glformat == TINYKTX_GL_FORMAT_BGRA_INTEGER) {
			return TKTX_B8G8R8A8_UINT;
		} else if(glformat == TINYKTX_GL_FORMAT_ABGR) {
			return TKTX_A8B8G8R8_UINT_PACK32;
		}
		break;

	case TINYKTX_GL_INTFORMAT_R16UI: return TKTX_R16_UINT;
	case TINYKTX_GL_INTFORMAT_RG16UI: return TKTX_R16G16_UINT;
	case TINYKTX_GL_INTFORMAT_RGB16UI:return TKTX_R16G16B16_UINT;
	case TINYKTX_GL_INTFORMAT_RGBA16UI: return TKTX_R16G16B16A16_UINT;

	case TINYKTX_GL_INTFORMAT_R32UI: return TKTX_R32_UINT;
	case TINYKTX_GL_INTFORMAT_RG32UI: return TKTX_R32G32_UINT;
	case TINYKTX_GL_INTFORMAT_RGB32UI: return TKTX_R32G32B32_UINT;
	case TINYKTX_GL_INTFORMAT_RGBA32UI: return TKTX_R32G32B32A32_UINT;

	case TINYKTX_GL_INTFORMAT_R16F: return TKTX_R16_SFLOAT;
	case TINYKTX_GL_INTFORMAT_RG16F: return TKTX_R16G16_SFLOAT;
	case TINYKTX_GL_INTFORMAT_RGB16F: return TKTX_R16G16B16_SFLOAT;
	case TINYKTX_GL_INTFORMAT_RGBA16F: return TKTX_R16G16B16A16_SFLOAT;

	case TINYKTX_GL_INTFORMAT_R32F: return TKTX_R32_SFLOAT;
	case TINYKTX_GL_INTFORMAT_RG32F: return TKTX_R32G32_SFLOAT;
	case TINYKTX_GL_INTFORMAT_RGB32F: return TKTX_R32G32B32_SFLOAT;
	case TINYKTX_GL_INTFORMAT_RGBA32F: return TKTX_R32G32B32A32_SFLOAT;

	case TINYKTX_GL_INTFORMAT_R11F_G11F_B10F: return TKTX_B10G11R11_UFLOAT_PACK32; //??
	case TINYKTX_GL_INTFORMAT_UNSIGNED_INT_10F_11F_11F_REV: return TKTX_B10G11R11_UFLOAT_PACK32; //?
	case TINYKTX_GL_INTFORMAT_RGB9_E5: return TKTX_E5B9G9R9_UFLOAT_PACK32;
	case TINYKTX_GL_INTFORMAT_SLUMINANCE8_ALPHA8: return TKTX_R8G8_SRGB;
	case TINYKTX_GL_INTFORMAT_SLUMINANCE8: return TKTX_R8_SRGB;
	case TINYKTX_GL_INTFORMAT_RGB565: return TKTX_R5G6B5_UNORM_PACK16;

	case TINYKTX_GL_INTFORMAT_ALPHA8: return TKTX_R8_UNORM;
	case TINYKTX_GL_INTFORMAT_ALPHA16: return TKTX_R16_UNORM;
	case TINYKTX_GL_INTFORMAT_LUMINANCE8: return TKTX_R8_UNORM;
	case TINYKTX_GL_INTFORMAT_LUMINANCE16: return TKTX_R16_UNORM;
	case TINYKTX_GL_INTFORMAT_LUMINANCE8_ALPHA8: return TKTX_R8G8_UNORM;
	case TINYKTX_GL_INTFORMAT_LUMINANCE16_ALPHA16: return TKTX_R16G16_UNORM;
	case TINYKTX_GL_INTFORMAT_INTENSITY8: return TKTX_R8_UNORM;
	case TINYKTX_GL_INTFORMAT_INTENSITY16: return TKTX_R16_UNORM;

	case TINYKTX_GL_INTFORMAT_ALPHA8_SNORM: return TKTX_R8_SNORM;
	case TINYKTX_GL_INTFORMAT_LUMINANCE8_SNORM: return TKTX_R8_SNORM;
	case TINYKTX_GL_INTFORMAT_LUMINANCE8_ALPHA8_SNORM: return TKTX_R8G8_SNORM;
	case TINYKTX_GL_INTFORMAT_INTENSITY8_SNORM: return TKTX_R8_SNORM;
	case TINYKTX_GL_INTFORMAT_ALPHA16_SNORM: return TKTX_R16_SNORM;
	case TINYKTX_GL_INTFORMAT_LUMINANCE16_SNORM: return TKTX_R16_SNORM;
	case TINYKTX_GL_INTFORMAT_LUMINANCE16_ALPHA16_SNORM: return TKTX_R16G16_SNORM;
	case TINYKTX_GL_INTFORMAT_INTENSITY16_SNORM: return TKTX_R16_SNORM;

	case TINYKTX_GL_INTFORMAT_RGB5_A1:
		if (gltype == TINYKTX_GL_TYPE_UNSIGNED_SHORT_1_5_5_5_REV) {
			return TKTX_A1R5G5B5_UNORM_PACK16;
		} else if (gltype == TINYKTX_GL_TYPE_UNSIGNED_SHORT_5_5_5_1) {
			return TKTX_R5G5B5A1_UNORM_PACK16;
		}
		break;

	case TINYKTX_GL_INTFORMAT_SRGB8:
	case TINYKTX_GL_INTFORMAT_SRGB8_ALPHA8:
		if (glformat == TINYKTX_GL_FORMAT_SLUMINANCE) {
			return TKTX_R8_SRGB;
		} else if (glformat == TINYKTX_GL_FORMAT_SLUMINANCE_ALPHA) {
			return TKTX_R8G8_SRGB;
		} else if (glformat == TINYKTX_GL_FORMAT_SRGB) {
			return TKTX_R8G8B8_SRGB;
		} else if (glformat == TINYKTX_GL_FORMAT_SRGB_ALPHA) {
			return TKTX_R8G8B8A8_SRGB;
		} else if (glformat == TINYKTX_GL_FORMAT_BGR) {
			return TKTX_B8G8R8_SRGB;
		} else if (glformat == TINYKTX_GL_FORMAT_BGRA) {
			return TKTX_B8G8R8A8_SRGB;
		} else if (glformat == TINYKTX_GL_FORMAT_ABGR) {
			return TKTX_A8B8G8R8_SRGB_PACK32;
		}
		break;
	case TINYKTX_GL_INTFORMAT_RGBA4:
		if(glformat == TINYKTX_GL_FORMAT_RGBA) {
			return TKTX_R4G4B4A4_UNORM_PACK16;
		} else if(glformat == TINYKTX_GL_FORMAT_BGRA) {
			return TKTX_B4G4R4A4_UNORM_PACK16;
		}
		break;

	case TINYKTX_GL_INTFORMAT_RGB10_A2:
		if(glformat == TINYKTX_GL_FORMAT_BGRA) {
			return TKTX_A2R10G10B10_UNORM_PACK32;
		} else if(glformat == TINYKTX_GL_FORMAT_RGBA) {
			return TKTX_A2B10G10R10_UNORM_PACK32;
		} else		if(glformat == TINYKTX_GL_FORMAT_BGRA_INTEGER) {
			return TKTX_A2R10G10B10_UINT_PACK32;
		} else if(glformat == TINYKTX_GL_FORMAT_RGBA_INTEGER) {
			return TKTX_A2B10G10R10_UINT_PACK32;
		}
		break;

		// can't handle yet
	case TINYKTX_GL_INTFORMAT_ALPHA4:
	case TINYKTX_GL_INTFORMAT_ALPHA12:
	case TINYKTX_GL_INTFORMAT_LUMINANCE4:
	case TINYKTX_GL_INTFORMAT_LUMINANCE12:
	case TINYKTX_GL_INTFORMAT_LUMINANCE4_ALPHA4:
	case TINYKTX_GL_INTFORMAT_LUMINANCE6_ALPHA2:
	case TINYKTX_GL_INTFORMAT_LUMINANCE12_ALPHA4:
	case TINYKTX_GL_INTFORMAT_LUMINANCE12_ALPHA12:
	case TINYKTX_GL_INTFORMAT_INTENSITY4:
	case TINYKTX_GL_INTFORMAT_INTENSITY12:
	case TINYKTX_GL_INTFORMAT_RGB2:
	case TINYKTX_GL_INTFORMAT_RGB4:
	case TINYKTX_GL_INTFORMAT_RGB5:
	case TINYKTX_GL_INTFORMAT_RGB10:
	case TINYKTX_GL_INTFORMAT_RGB12:
	case TINYKTX_GL_INTFORMAT_RGBA2:
	case TINYKTX_GL_INTFORMAT_RGBA12:
	case TINYKTX_GL_INTFORMAT_FLOAT_32_UNSIGNED_INT_24_8_REV:
	case TINYKTX_GL_COMPRESSED_SRGB_ALPHA_PVRTC_2BPPV2:
	case TINYKTX_GL_COMPRESSED_SRGB_ALPHA_PVRTC_4BPPV2:
	case TINYKTX_GL_COMPRESSED_ATC_RGB:
	case TINYKTX_GL_COMPRESSED_ATC_RGBA_EXPLICIT_ALPHA:
	case TINYKTX_GL_COMPRESSED_ATC_RGBA_INTERPOLATED_ALPHA:
	default: break;
	}
	return TKTX_UNDEFINED;
}

uint32_t TinyKtx_ElementCountFromGLFormat(uint32_t fmt){
	switch(fmt) {
	case TINYKTX_GL_FORMAT_RED:
	case TINYKTX_GL_FORMAT_GREEN:
	case TINYKTX_GL_FORMAT_BLUE:
	case TINYKTX_GL_FORMAT_ALPHA:
	case TINYKTX_GL_FORMAT_LUMINANCE:
	case TINYKTX_GL_FORMAT_INTENSITY:
	case TINYKTX_GL_FORMAT_RED_INTEGER:
	case TINYKTX_GL_FORMAT_GREEN_INTEGER:
	case TINYKTX_GL_FORMAT_BLUE_INTEGER:
	case TINYKTX_GL_FORMAT_ALPHA_INTEGER:
	case TINYKTX_GL_FORMAT_SLUMINANCE:
	case TINYKTX_GL_FORMAT_RED_SNORM:
		return 1;

	case TINYKTX_GL_FORMAT_RG_INTEGER:
	case TINYKTX_GL_FORMAT_RG:
	case TINYKTX_GL_FORMAT_LUMINANCE_ALPHA:
	case TINYKTX_GL_FORMAT_SLUMINANCE_ALPHA:
	case TINYKTX_GL_FORMAT_RG_SNORM:
		return 2;

	case TINYKTX_GL_FORMAT_BGR:
	case TINYKTX_GL_FORMAT_RGB:
	case TINYKTX_GL_FORMAT_SRGB:
	case TINYKTX_GL_FORMAT_RGB_INTEGER:
	case TINYKTX_GL_FORMAT_BGR_INTEGER:
	case TINYKTX_GL_FORMAT_RGB_SNORM:
		return 3;

	case TINYKTX_GL_FORMAT_BGRA:
	case TINYKTX_GL_FORMAT_RGBA:
	case TINYKTX_GL_FORMAT_ABGR:
	case TINYKTX_GL_FORMAT_SRGB_ALPHA:
	case TINYKTX_GL_FORMAT_RGBA_INTEGER:
	case TINYKTX_GL_FORMAT_BGRA_INTEGER:
	case TINYKTX_GL_FORMAT_RGBA_SNORM:
		return 4;
	}

	return 0;
}
bool TinyKtx_ByteDividableFromGLType(uint32_t type){
	switch(type) {
	case TINYKTX_GL_TYPE_COMPRESSED:
	case TINYKTX_GL_TYPE_UNSIGNED_BYTE_3_3_2:
	case TINYKTX_GL_TYPE_UNSIGNED_SHORT_4_4_4_4:
	case TINYKTX_GL_TYPE_UNSIGNED_SHORT_5_5_5_1:
	case TINYKTX_GL_TYPE_UNSIGNED_INT_8_8_8_8:
	case TINYKTX_GL_TYPE_UNSIGNED_INT_10_10_10_2:
	case TINYKTX_GL_TYPE_UNSIGNED_BYTE_2_3_3_REV:
	case TINYKTX_GL_TYPE_UNSIGNED_SHORT_5_6_5:
	case TINYKTX_GL_TYPE_UNSIGNED_SHORT_5_6_5_REV:
	case TINYKTX_GL_TYPE_UNSIGNED_SHORT_4_4_4_4_REV:
	case TINYKTX_GL_TYPE_UNSIGNED_SHORT_1_5_5_5_REV:
	case TINYKTX_GL_TYPE_UNSIGNED_INT_8_8_8_8_REV:
	case TINYKTX_GL_TYPE_UNSIGNED_INT_2_10_10_10_REV:
	case TINYKTX_GL_TYPE_UNSIGNED_INT_24_8:
	case TINYKTX_GL_TYPE_UNSIGNED_INT_5_9_9_9_REV:
	case TINYKTX_GL_TYPE_UNSIGNED_INT_10F_11F_11F_REV:
	case TINYKTX_GL_TYPE_FLOAT_32_UNSIGNED_INT_24_8_REV:
		return false;
	case TINYKTX_GL_TYPE_BYTE:
	case TINYKTX_GL_TYPE_UNSIGNED_BYTE:
	case TINYKTX_GL_TYPE_SHORT:
	case TINYKTX_GL_TYPE_UNSIGNED_SHORT:
	case TINYKTX_GL_TYPE_INT:
	case TINYKTX_GL_TYPE_UNSIGNED_INT:
	case TINYKTX_GL_TYPE_FLOAT:
	case TINYKTX_GL_TYPE_DOUBLE:
	case TINYKTX_GL_TYPE_HALF_FLOAT:
		return true;
	}
	return false;
}
TinyKtx_Format TinyKtx_GetFormat(TinyKtx_ContextHandle handle) {
	uint32_t glformat;
	uint32_t gltype;
	uint32_t glinternalformat;
	uint32_t typesize;
	uint32_t glbaseinternalformat;

	TinyKtx_Context *ctx = (TinyKtx_Context *) handle;
	if (ctx == NULL)
		return TKTX_UNDEFINED;

	if (ctx->headerValid == false) {
		ctx->callbacks.error(ctx->user, "Header data hasn't been read yet or its invalid");
		return TKTX_UNDEFINED;
	}
#ifdef TINY_KTX_EXPERIMENTAL_KTX2_SUPPORT
	if(ctx->v2) {
		// TODO handle DFD only described formats (VK_FORMAT_UNDEFINED)
		return (TinyKtx_Format)ctx->headerV2.vkFormat;
	}
#endif

	if(TinyKtx_GetFormatGL(handle, &glformat, &gltype, &glinternalformat, &typesize, &glbaseinternalformat) == false)
		return TKTX_UNDEFINED;

	return TinyKtx_CrackFormatFromGL(glformat, gltype, glinternalformat, typesize);
}
static uint32_t TinyKtx_MipMapReduce(uint32_t value, uint32_t mipmaplevel) {

	// handle 0 being passed in
	if(value <= 1) return 1;

	// there are better ways of doing this (log2 etc.) but this doesn't require any
	// dependecies and isn't used enough to matter imho
	for (uint32_t i = 0u; i < mipmaplevel;++i) {
		if(value <= 1) return 1;
		value = value / 2;
	}
	return value;
}

// KTX specifys GL_UNPACK_ALIGNMENT = 4 which means some files have unexpected padding
// that probably means you can't just memcpy the data out if you aren't using a GL
// texture with GL_UNPACK_ALIGNMENT of 4
// this will be true if this mipmap level is 'unpacked' so has padding on each row
// you will need to handle.
bool TinyKtx_IsMipMapLevelUnpacked(TinyKtx_ContextHandle handle, uint32_t mipmaplevel) {
	TinyKtx_Context *ctx = (TinyKtx_Context *) handle;
	if (ctx == NULL)
		return false;
	if (ctx->headerValid == false) {
		ctx->callbacks.error(ctx->user, "Header data hasn't been read yet or its invalid");
		return false;
	}

#ifdef TINY_KTX_EXPERIMENTAL_KTX2_SUPPORT
	if(ctx->v2) {
		// TODO GL decoder from vkformat and/or DFD
		return false;
	}
#endif

	if (ctx->header.glTypeSize < 4 &&
			TinyKtx_ByteDividableFromGLType(ctx->header.glType)) {

		uint32_t const s = ctx->header.glTypeSize;
		uint32_t const n = TinyKtx_ElementCountFromGLFormat(ctx->header.glFormat);
		if (n == 0) {
			ctx->callbacks.error(ctx->user, "TinyKtx_ElementCountFromGLFormat error");
			return false;
		}

		uint32_t const w = TinyKtx_MipMapReduce(ctx->header.pixelWidth, mipmaplevel);
		uint32_t const snl = s * n * w;
		uint32_t const k = ((snl + 3u) & ~3u);

		if(k != snl) {
			return true;
		}
	}
	return false;
}
uint32_t TinyKtx_UnpackedRowStride(TinyKtx_ContextHandle handle, uint32_t mipmaplevel) {
	TinyKtx_Context *ctx = (TinyKtx_Context *) handle;
	if (ctx == NULL)
		return 0;
	if (ctx->headerValid == false) {
		ctx->callbacks.error(ctx->user, "Header data hasn't been read yet or its invalid");
		return 0;
	}

#ifdef TINY_KTX_EXPERIMENTAL_KTX2_SUPPORT
	if(ctx->v2) {
		// TODO GL decoder from vkformat and/or DFD
		return 0;
	}
#endif

	if (ctx->header.glTypeSize < 4 &&
			TinyKtx_ByteDividableFromGLType(ctx->header.glType)) {

		uint32_t const s = ctx->header.glTypeSize;
		uint32_t const n = TinyKtx_ElementCountFromGLFormat(ctx->header.glFormat);
		if (n == 0) {
			ctx->callbacks.error(ctx->user, "TinyKtx_ElementCountFromGLFormat error");
			return 0;
		}

		uint32_t const w = TinyKtx_MipMapReduce(ctx->header.pixelWidth, mipmaplevel);
		uint32_t const snl = s * n * w;
		uint32_t const k = ((snl + 3u) & ~3u);
		return k;
	}
	return 0;
}


bool TinyKtx_WriteImageGL(TinyKtx_WriteCallbacks const *callbacks,
													void *user,
													uint32_t width,
													uint32_t height,
													uint32_t depth,
													uint32_t slices,
													uint32_t mipmaplevels,
													uint32_t format,
													uint32_t internalFormat,
													uint32_t baseFormat,
													uint32_t type,
													uint32_t typeSize,
													bool cubemap,
													uint32_t const *mipmapsizes,
													void const **mipmaps) {

	TinyKtx_Header header;
	memcpy(header.identifier, TinyKtx_fileIdentifier, 12);
	header.endianness = 0x04030201;
	header.glFormat = format;
	header.glInternalFormat = internalFormat;
	header.glBaseInternalFormat = baseFormat;
	header.glType = type;
	header.glTypeSize = typeSize;
	header.pixelWidth = width;
	header.pixelHeight = (height == 1) ? 0 : height;
	header.pixelDepth = (depth == 1) ? 0 : depth;
	header.numberOfArrayElements = (slices == 1) ? 0 : slices;
	header.numberOfFaces = cubemap ? 6 : 1;
	header.numberOfMipmapLevels = mipmaplevels;
	// TODO keyvalue pair data
	header.bytesOfKeyValueData = 0;
	callbacks->write(user, &header, sizeof(TinyKtx_Header));

	uint32_t w = (width == 0) ? 1 : width;
	uint32_t h = (height == 0) ? 1 : height;
	uint32_t d = (depth == 0) ? 1 : depth;
	uint32_t sl = (slices == 0) ? 1 : slices;
	static uint8_t const padding[4] = {0, 0, 0, 0};

	for (uint32_t i = 0u; i < mipmaplevels; ++i) {

		bool writeRaw = true;

		if(	typeSize < 4 &&
				TinyKtx_ByteDividableFromGLType(type)) {

			uint32_t const s = typeSize;
			uint32_t const n = TinyKtx_ElementCountFromGLFormat(format);
			if (n == 0) {
				callbacks->error(user, "TinyKtx_ElementCountFromGLFormat error");
				return false;
			}
			uint32_t const snl = s * n * w;
			uint32_t const k = ((snl + 3u) & ~3u);

			uint32_t const size = (k * h * d * snl);
			if (size < mipmapsizes[i]) {
				callbacks->error(user, "Internal size error, padding should only ever expand");
				return false;
			}

			// if we need to expand for padding take the slow per row write route
			if (size > mipmapsizes[i]) {
				callbacks->write(user, &size, sizeof(uint32_t));

				uint8_t const *src = mipmaps[i];
				for (uint32_t ww = 0u; ww < sl; ++ww) {
					for (uint32_t zz = 0; zz < d; ++zz) {
						for (uint32_t yy = 0; yy < h; ++yy) {
							callbacks->write(user, src, snl);
							callbacks->write(user, padding, k - snl);
							src += snl;
						}
					}
				}
				uint32_t paddCount = ((size + 3u) & ~3u) - size;
				if(paddCount > 3) {
					callbacks->error(user, "Internal error: padding bytes > 3");
					return false;
				}

				callbacks->write(user, padding, paddCount);
				writeRaw = false;
			}
		}

		if(writeRaw) {
			uint32_t const size = ((mipmapsizes[i] + 3u) & ~3u);
			callbacks->write(user, mipmapsizes + i, sizeof(uint32_t));
			callbacks->write(user, mipmaps[i], mipmapsizes[i]);
			callbacks->write(user, padding, size - mipmapsizes[i]);
		}

		if(w > 1) w = w / 2;
		if(h > 1) h = h / 2;
		if(d > 1) d = d / 2;
	}

	return true;
}

bool TinyKtx_WriteImage(TinyKtx_WriteCallbacks const *callbacks,
												void *user,
												uint32_t width,
												uint32_t height,
												uint32_t depth,
												uint32_t slices,
												uint32_t mipmaplevels,
												TinyKtx_Format format,
												bool cubemap,
												uint32_t const *mipmapsizes,
												void const **mipmaps) {
	uint32_t glformat;
	uint32_t glinternalFormat;
	uint32_t gltype;
	uint32_t gltypeSize;
	if (TinyKtx_CrackFormatToGL(format, &glformat, &gltype, &glinternalFormat, &gltypeSize) == false)
		return false;

	return TinyKtx_WriteImageGL(callbacks,
															user,
															width,
															height,
															depth,
															slices,
															mipmaplevels,
															glformat,
															glinternalFormat,
															glinternalFormat, //??
															gltype,
															gltypeSize,
															cubemap,
															mipmapsizes,
															mipmaps
	);

}
#endif

#ifdef __cplusplus
};
#endif

#endif // end header
/*
MIT License

Copyright (c) 2019 DeanoC

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/
